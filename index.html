<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SNG's Funky 3D Hustle Board</title>

    <script src="https://www.gstatic.com/firebasejs/9.6.7/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.7/firebase-firestore-compat.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/dist/confetti.browser.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Poppins:wght@700;800&display=swap" rel="stylesheet">

    <link rel="manifest" href="manifest.json"> <meta name="apple-mobile-web-app-capable" content="yes"> <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"> <meta name="apple-mobile-web-app-title" content="SNG Board"> <link rel="apple-touch-icon" href="icon-192.png"> <meta name="theme-color" content="#f97316"> <style>
        :root {
            /* Color variables */
            --column-bg: rgba(17, 24, 39, 0.75); --column-header-text: #f1f5f9;
            --task-bg: #ffffff; --task-text: #1f2937;
            --idea-task-bg: #e2e8f0; --idea-task-text: #334155;
            --accent-todo: #f59e0b; --accent-inprogress: #eab308; --accent-done: #22c55e;
            --button-primary-bg: #dc2626; --button-primary-hover: #b91c1c;
            --button-secondary-bg: #16a34a; --button-secondary-hover: #15803d;
            --button-cancel-bg: #64748b; --button-cancel-hover: #475569;
            --quote-bg: rgba(255, 255, 255, 0.1); --quote-border: rgba(255, 255, 255, 0.3); --quote-text: #f8fafc;
            --summary-bg: rgba(30, 41, 59, 0.8); --summary-header: #facc15; --summary-text: #cbd5e1; --summary-strong: #fde047;
            --idea-box-bg: rgba(51, 65, 85, 0.8);
            --modal-bg: rgba(17, 24, 39, 0.9); --modal-content-bg: #1f2937;
            --progress-bar-bg: #e5e7eb; /* gray-200 */
            --progress-bar-fill: var(--accent-inprogress); /* Use in-progress accent */
            --timer-text-color: #4b5563; /* gray-600 */
            --timer-text-expired-color: #dc2626; /* red-600 */
        }

        body {
            font-family: 'Inter', sans-serif;
            background-image: url('https://raw.githubusercontent.com/sniting/sng-hustle-board/main/game-of-thrones-season-8-cartoon-1y7i9ou5f2clujq6.jpg');
            background-size: cover; background-position: center center; background-repeat: no-repeat; background-attachment: fixed;
            background-color: #374151; padding: 2rem 1rem 5rem 1rem; color: var(--column-header-text);
            perspective: 1800px; overflow-x: hidden; min-height: 100vh;
        }
        h1, h2, h3 { font-family: 'Poppins', sans-serif; font-weight: 800; letter-spacing: 0.02em; }
        #main-content-wrapper { max-width: 1200px; margin: 0 auto; }
        #main-title { color: #ffffff; text-shadow: 2px 2px 4px rgba(0,0,0,0.6); animation: pulse-glow 3s infinite alternate; }
        #subtitle { color: #f1f5f9; text-shadow: 1px 1px 3px rgba(0,0,0,0.5); }
        @keyframes pulse-glow { from { text-shadow: 2px 2px 4px rgba(0,0,0,0.5), 0 0 5px rgba(255,255,255,0.3); } to { text-shadow: 2px 2px 6px rgba(0,0,0,0.6), 0 0 15px rgba(255,255,255,0.5); } }

        /* Kanban Column Styling */
        .kanban-column {
            min-height: 350px; background-color: var(--column-bg); backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 0.75rem; padding: 1.25rem;
            transition: all 0.35s cubic-bezier(0.25, 0.8, 0.25, 1); box-shadow: 0 10px 20px rgba(0, 0, 0, 0.25);
            transform: rotateX(2deg) rotateY(-1deg); display: flex; flex-direction: column;
        }
        .kanban-column:hover { transform: rotateX(0deg) rotateY(0deg) scale(1.03) translateZ(20px); box-shadow: 0 15px 35px rgba(0, 0, 0, 0.35); }
        .kanban-column h2 {
            color: var(--column-header-text); text-transform: uppercase; font-weight: 700; display: flex;
            align-items: center; justify-content: center; gap: 0.6rem; border-bottom: 2px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 0.75rem; margin-bottom: 1.25rem; flex-shrink: 0;
        }
        .tasks-container { flex-grow: 1; overflow-y: auto; min-height: 100px; padding-top: 5px; }

        /* Task Card Styling (Daily Tasks) */
        .kanban-task {
            background-color: var(--task-bg); color: var(--task-text); border-radius: 0.5rem;
            padding: 0.8rem 1.1rem; margin-bottom: 1rem; cursor: grab; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            transition: all 0.25s ease-in-out; word-break: break-word; position: relative;
            border-left: 5px solid var(--accent-todo);
        }
        #inprogress .kanban-task { border-left-color: var(--accent-inprogress); }
        #done .kanban-task { border-left-color: var(--accent-done); }

        .task-content-display {}
        .task-time-info { font-size: 0.8rem; color: #475569; margin-top: 0.4rem; display: block; font-weight: 600; }
        .task-time-info .duration { color: #57534e; margin-left: 0.5rem; font-weight: 500; }
        .task-completion-date { font-size: 0.75rem; color: #64748b; margin-top: 0.25rem; display: block; }

        /* In Progress Timer/Progress Bar Styles */
        .task-progress-container { margin-top: 0.75rem; height: 16px; display: flex; align-items: center; gap: 0.5rem; }
        .progress-bar { flex-grow: 1; height: 8px; background-color: var(--progress-bar-bg); border-radius: 4px; overflow: hidden; }
        .progress-bar-fill { height: 100%; width: 0%; background-color: var(--progress-bar-fill); border-radius: 4px; transition: width 0.5s ease-out; }
        .remaining-time { font-size: 0.75rem; font-weight: 500; color: var(--timer-text-color); white-space: nowrap; flex-shrink: 0; }
        .remaining-time.expired { color: var(--timer-text-expired-color); font-weight: 700; }

        .kanban-task:active:not(.editing) { cursor: grabbing; box-shadow: 0 8px 16px rgba(0, 0, 0, 0.15); transform: scale(1.03); }
        .dragging { opacity: 0.5; transform: rotate(5deg) scale(1.08) skew(-5deg, -2deg); }
        .idea-task.dragging { background-color: #a7f3d0; border: 1px dashed #059669; }
        .drag-over { background-color: rgba(70, 88, 116, 0.8); transform: scale(1.01); }

        /* Confetti Canvas Styling */
        #confetti-canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 9999; }

        /* Time/Date/Quote Display Styling */
        #time-date-display, #selected-date-display, #motivational-quote { background-color: rgba(30, 41, 59, 0.6); backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.2); padding: 0.8rem 1.2rem; border-radius: 0.6rem; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15); text-align: center; margin-bottom: 1.5rem; max-width: 550px; margin-left: auto; margin-right: auto; color: #f1f5f9; font-weight: 600; text-shadow: 1px 1px 2px rgba(0,0,0,0.3); transition: all 0.3s ease-out; }
        #time-date-display:hover, #selected-date-display:hover, #motivational-quote:hover { transform: translateY(-4px) scale(1.02); box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2); }
        #selected-date-display { background-color: rgba(51, 65, 85, 0.7); color: #ffffff; font-weight: 700; margin-top: 0.5rem; border-color: rgba(255, 255, 255, 0.3); }
        #motivational-quote { background-color: rgba(17, 24, 39, 0.65); border: 1px solid var(--quote-border); color: var(--quote-text); padding: 1rem 1.2rem; font-size: 1rem; font-weight: 500; font-style: normal; text-shadow: 1px 1px 2px rgba(0,0,0,0.4); margin-bottom: 2rem; }

        /* Date Selector Styling */
        #date-selector-container { text-align: center; margin-bottom: 1.5rem; }
        #date-selector-container label { margin-right: 0.5rem; font-weight: 700; color: #f1f5f9; text-shadow: 1px 1px 2px rgba(0,0,0,0.3); }
        #date-selector { padding: 0.6rem 0.8rem; border: 1px solid rgba(255,255,255,0.3); border-radius: 0.5rem; box-shadow: inset 0 1px 3px 0 rgba(0,0,0,0.1); cursor: pointer; background-color: rgba(30, 41, 59, 0.7); color: #ffffff; font-weight: 500; }

        /* Add Task Form Container Styling */
         #add-task-form-container { background-color: rgba(30, 41, 59, 0.85); backdrop-filter: blur(12px); border: 1px solid rgba(255, 255, 255, 0.2); padding: 1.75rem; border-radius: 0.75rem; box-shadow: 0 8px 20px rgba(0, 0, 0, 0.25); transition: all 0.35s cubic-bezier(0.25, 0.8, 0.25, 1); transform: rotateX(1deg) rotateY(1deg); margin-bottom: 2.5rem; }
         #add-task-form-container:hover { transform: rotateX(0deg) rotateY(0deg) scale(1.02) translateZ(15px); box-shadow: 0 12px 25px rgba(0, 0, 0, 0.3); }
        #add-task-form { display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; align-items: end; }
        #add-task-form > div:nth-child(1) { grid-column: span 2; }
        #add-task-form > div:nth-child(4) { grid-column: span 2; margin-top: 0.5rem; }
        @media (min-width: 768px) { #add-task-form { grid-template-columns: minmax(150px, 3fr) 1fr 1fr auto; gap: 1rem; } #add-task-form > div:nth-child(1) { grid-column: auto; } #add-task-form > div:nth-child(4) { grid-column: auto; margin-top: 0; } }
        #add-task-form label { display: block; font-size: 0.9rem; font-weight: 600; color: #cbd5e1; margin-bottom: 0.4rem; }
        #add-task-form input[type="text"], #add-task-form input[type="time"] { width: 100%; border: 1px solid #475569; border-radius: 0.5rem; padding: 0.6rem 0.9rem; box-shadow: inset 0 1px 3px 0 rgba(0,0,0,0.1); font-size: 0.9rem; background-color: #1e293b; color: #f1f5f9; }
        #add-task-form button { background-color: var(--button-primary-bg); color: white; font-weight: 700; padding: 0.6rem 1.5rem; border-radius: 0.5rem; transition: all 0.2s ease-in-out; box-shadow: 0 3px 6px rgba(0,0,0,0.15); border: none; cursor: pointer; text-transform: uppercase; }
        #add-task-form button:hover { background-color: var(--button-primary-hover); transform: translateY(-2px) scale(1.02); box-shadow: 0 5px 10px rgba(0,0,0,0.2); }

        /* Idea Box Styling */
        #idea-box-container { background-color: var(--idea-box-bg); backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 0.75rem; padding: 1.5rem; margin-top: 2.5rem; margin-bottom: 2.5rem; max-width: 6xl; margin-left: auto; margin-right: auto; box-shadow: 0 6px 15px rgba(0, 0, 0, 0.2); }
        #idea-box-container h3 { color: #e0f2fe; text-align: center; margin-bottom: 1rem; font-weight: 700; text-shadow: 1px 1px 2px rgba(0,0,0,0.3); }
        #add-idea-form { display: flex; gap: 0.75rem; margin-bottom: 1.25rem; }
        #idea-task-input { flex-grow: 1; border: 1px solid #475569; border-radius: 0.5rem; padding: 0.6rem 0.9rem; box-shadow: inset 0 1px 3px 0 rgba(0,0,0,0.1); font-size: 0.9rem; background-color: #1e293b; color: #f1f5f9; }
        #add-idea-task-btn { background-color: var(--button-secondary-bg); color: white; font-weight: 600; padding: 0.6rem 1.2rem; border-radius: 0.5rem; transition: all 0.2s ease-in-out; box-shadow: 0 2px 5px rgba(0,0,0,0.15); border: none; cursor: pointer; white-space: nowrap; }
        #add-idea-task-btn:hover { background-color: var(--button-secondary-hover); transform: translateY(-1px) scale(1.02); box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
        #idea-task-list { max-height: 250px; overflow-y: auto; padding-right: 5px; }
        .idea-task { background-color: var(--idea-task-bg); color: var(--idea-task-text); border-radius: 0.375rem; padding: 0.6rem 0.9rem; margin-bottom: 0.75rem; cursor: grab; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08); transition: all 0.2s ease-in-out; word-break: break-word; position: relative; display: flex; justify-content: space-between; align-items: center; border-left: 4px solid #60a5fa; }
         .idea-task span { flex-grow: 1; margin-right: 0.5rem; }
        .idea-task:active { cursor: grabbing; }
        .delete-idea-task-btn { background: none; border: none; color: #ef4444; font-size: 1.1rem; line-height: 1; cursor: pointer; padding: 0.1rem 0.2rem; opacity: 0.5; transition: all 0.2s ease; flex-shrink: 0; }
        .idea-task:hover .delete-idea-task-btn { opacity: 1; }
        .delete-idea-task-btn:hover { transform: scale(1.2); color: #b91c1c; }

        /* Daily Summary Styling */
        #daily-summary { background-color: var(--summary-bg); border: 1px solid rgba(255, 255, 255, 0.15); padding: 1.5rem; border-radius: 0.75rem; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); margin-top: 2.5rem; max-width: 6xl; margin-left: auto; margin-right: auto; }
        #daily-summary h3 { color: var(--summary-header); font-weight: 700; margin-bottom: 0.75rem; }
        #daily-summary p { color: var(--summary-text); font-size: 0.95rem; line-height: 1.6; }
        #daily-summary strong { font-weight: 700; color: var(--summary-strong); }
        #daily-summary .motivation-suffix { display: block; margin-top: 1rem; font-style: italic; color: #93c5fd; }

        /* Edit/Delete Styles (for daily tasks) */
        .task-edit-form { display: flex; flex-direction: column; gap: 0.6rem; }
        .task-edit-form input[type="text"], .task-edit-form input[type="time"] { width: 100%; border: 1px solid #94a3b8; border-radius: 0.375rem; padding: 0.4rem 0.6rem; font-size: 0.875rem; background-color: #f8fafc; color: #1e293b; }
        .task-edit-form .edit-time-inputs { display: flex; gap: 0.6rem; }
        .task-edit-form .edit-time-inputs > div { flex-grow: 1; }
        .task-edit-form .edit-buttons { display: flex; justify-content: flex-end; gap: 0.6rem; margin-top: 0.6rem; }
        .task-edit-form button { padding: 0.3rem 0.7rem; border-radius: 0.375rem; font-size: 0.8rem; font-weight: 700; transition: all 0.2s ease; border: none; cursor: pointer; text-transform: uppercase; }
        .edit-save-btn { background-color: var(--button-secondary-bg); color: white; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .edit-save-btn:hover { background-color: var(--button-secondary-hover); transform: scale(1.05); box-shadow: 0 3px 6px rgba(0,0,0,0.15); }
        .edit-cancel-btn { background-color: var(--button-cancel-bg); color: #1e293b; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .edit-cancel-btn:hover { background-color: var(--button-cancel-hover); transform: scale(1.05); box-shadow: 0 3px 6px rgba(0,0,0,0.15); }
        .delete-task-btn { position: absolute; top: 0.4rem; right: 0.4rem; background: none; border: none; color: #fca5a5; font-size: 1.2rem; line-height: 1; cursor: pointer; padding: 0.1rem; opacity: 0.4; transition: all 0.2s ease; }
        .kanban-task:hover .delete-task-btn { opacity: 0.8; }
        .delete-task-btn:hover { opacity: 1; color: #ef4444; transform: scale(1.15) rotate(10deg); }
        .kanban-task.editing { cursor: default; border-left-color: var(--button-primary-bg); }

        /* Highlight effect for auto-moved tasks */
        .task-just-moved { background-color: rgba(250, 204, 21, 0.3); animation: highlight-fade 1.8s ease-out; }
        @keyframes highlight-fade { 0% { background-color: rgba(250, 204, 21, 0.6); } 100% { background-color: var(--task-bg); } }

        /* Time Prompt Modal Styling */
        #time-prompt-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); backdrop-filter: blur(5px); display: none; align-items: center; justify-content: center; z-index: 10000; }
        #time-prompt-modal.active { display: flex; }
        .modal-content { background-color: var(--modal-content-bg); padding: 2rem; border-radius: 0.75rem; box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4); width: 90%; max-width: 400px; border: 1px solid rgba(255, 255, 255, 0.2); }
        .modal-content h3 { color: #e0f2fe; text-align: center; margin-bottom: 1.5rem; font-size: 1.25rem; }
        .modal-content label { display: block; font-size: 0.9rem; font-weight: 600; color: #cbd5e1; margin-bottom: 0.4rem; margin-top: 1rem; }
        .modal-content input[type="time"] { width: 100%; border: 1px solid #475569; border-radius: 0.5rem; padding: 0.6rem 0.9rem; box-shadow: inset 0 1px 3px 0 rgba(0,0,0,0.1); font-size: 0.9rem; background-color: #334155; color: #f1f5f9; }
        .modal-buttons { display: flex; justify-content: flex-end; gap: 0.75rem; margin-top: 2rem; }
        .modal-buttons button { padding: 0.5rem 1.2rem; border-radius: 0.5rem; font-weight: 700; transition: all 0.2s ease; border: none; cursor: pointer; text-transform: uppercase; font-size: 0.9rem; }
        #modal-save-btn { background-color: var(--button-secondary-bg); color: white; }
        #modal-save-btn:hover { background-color: var(--button-secondary-hover); transform: scale(1.03); }
        #modal-cancel-btn { background-color: var(--button-cancel-bg); color: white; }
        #modal-cancel-btn:hover { background-color: var(--button-cancel-hover); transform: scale(1.03); }

    </style>
</head>
<body class="p-4 md:p-8">

    <div id="main-content-wrapper">

        <h1 id="main-title" class="text-5xl font-extrabold text-center mb-2">SNG's Hustle Board</h1>
        <p id="subtitle" class="text-center text-lg mb-6">Plan & Conquer.</p>

        <div id="time-date-display" class="text-base">Loading time...</div>
        <div id="motivational-quote">Loading inspiration...</div>
        <div id="date-selector-container">
            <label for="date-selector">Select Date:</label>
            <input type="date" id="date-selector">
        </div>
        <div id="selected-date-display" class="text-lg">Loading tasks for...</div>

        <div class="mb-10 max-w-xl mx-auto" id="add-task-form-container">
            <h2 class="text-2xl font-bold mb-5 text-center text-slate-100">Add New Hustle (Today)</h2>
            <div id="add-task-form">
                <div>
                    <label for="new-task-input">Task:</label>
                    <input type="text" id="new-task-input" placeholder="Define the next victory..." class="focus:outline-none focus:ring-2 focus:ring-red-500 focus:border-transparent">
                </div>
                <div>
                    <label for="new-task-start-time">Start:</label>
                    <input type="time" id="new-task-start-time" class="focus:outline-none focus:ring-2 focus:ring-red-500 focus:border-transparent">
                </div>
                <div>
                    <label for="new-task-end-time">End:</label>
                    <input type="time" id="new-task-end-time" class="focus:outline-none focus:ring-2 focus:ring-red-500 focus:border-transparent">
                </div>
                <div>
                    <button id="add-task-btn" class="w-full">Lock It In</button>
                </div>
            </div>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-8 max-w-6xl mx-auto">
            <div id="todo" class="kanban-column" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event)">
                <h2 class="text-xl mb-5">🎯 To Do</h2>
                <div class="tasks-container">
                    </div>
            </div>
            <div id="inprogress" class="kanban-column" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event)">
                <h2 class="text-xl mb-5">🔥 In Progress</h2>
                 <div class="tasks-container">
                    </div>
            </div>
            <div id="done" class="kanban-column" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event)">
                <h2 class="text-xl mb-5">🏆 Done!</h2>
                 <div class="tasks-container">
                    </div>
            </div>
        </div>

        <div id="idea-box-container">
            <h3 class="text-xl font-bold">💡 Idea Box (Unscheduled Tasks)</h3>
            <div id="add-idea-form">
                <input type="text" id="idea-task-input" placeholder="Capture a new idea..." class="focus:outline-none focus:ring-2 focus:ring-blue-400 focus:border-transparent">
                <button id="add-idea-task-btn">Add Idea</button>
            </div>
            <div id="idea-task-list">
                <p class="text-slate-400 text-center italic">Loading ideas...</p>
                </div>
        </div>

        <div id="daily-summary" class="hidden"> <h3 class="text-xl font-bold">Daily Wins Recap!</h3>
            <p id="summary-content">No summary available yet.</p>
        </div>

    </div> <canvas id="confetti-canvas"></canvas>

    <div id="time-prompt-modal">
        <div class="modal-content">
            <h3>Schedule Idea Task</h3>
            <p id="modal-task-text" class="text-slate-300 mb-4 text-center"></p> <div>
                <label for="modal-start-time">Start Time:</label>
                <input type="time" id="modal-start-time">
            </div>
            <div>
                <label for="modal-end-time">End Time:</label>
                <input type="time" id="modal-end-time">
            </div>
            <div class="modal-buttons">
                <button id="modal-cancel-btn">Cancel</button>
                <button id="modal-save-btn">Save to Schedule</button>
            </div>
        </div>
    </div>
    <script>
        // --- Firebase Configuration ---
        // Using the config provided by the user for sng-hustle-board-standalone
        const firebaseConfig = {
          apiKey: "AIzaSyBygcOaz8etf0XycZ4ILTrUkSXD-SKhFVM",
          authDomain: "sng-hustle-board-standalone.firebaseapp.com",
          projectId: "sng-hustle-board-standalone",
          storageBucket: "sng-hustle-board-standalone.appspot.com", // Corrected .appspot.com if needed
          messagingSenderId: "892064086812",
          appId: "1:892064086812:web:4f0aeec9a6bd24c92958d9"
        };
        // --- End Firebase Configuration ---


        // --- Initialize Firebase ---
        let db;
        try {
            if (!firebase.apps.length) { firebase.initializeApp(firebaseConfig); }
            else { firebase.app(); }
            db = firebase.firestore();
            console.log("Firebase initialized successfully with sng-hustle-board-standalone config.");
        } catch (error) {
            console.error("Firebase initialization failed:", error);
            // Display a more prominent error if initialization fails
            const errorDiv = document.createElement('div');
            errorDiv.textContent = "CRITICAL ERROR: Could not initialize Firebase. Check configuration and console logs.";
            errorDiv.style.cssText = 'background-color: #b91c1c; color: white; padding: 15px; text-align: center; position: fixed; top: 0; left: 0; width: 100%; z-index: 10000; font-weight: bold;';
            document.body.prepend(errorDiv);
            // Optionally disable all functionality
            // document.querySelectorAll('button, input').forEach(el => el.disabled = true);
        }

        // --- Firestore Collection References (Using Renamed Collections) ---
        const hustleTasksCollection = db ? db.collection("hustle_tasks") : null; // For daily scheduled tasks
        const hustleArchiveCollection = db ? db.collection("hustle_archive") : null; // For archived tasks
        const hustleIdeaBoxCollection = db ? db.collection("hustle_ideaBoxTasks") : null; // For unscheduled idea tasks

        // --- Constants ---
        const BOSTON_TIMEZONE = 'America/New_York';
        const TASK_CHECK_INTERVAL = 60000; // 1 minute for auto-move check
        const TIMER_UPDATE_INTERVAL = 15000; // Update progress timers every 15 seconds (adjust as needed)
        const LAST_MINUTE_INTERVAL = 1000; // Update every second during the last minute

        // --- Motivational Quotes & Suffixes ---
        // *** UPDATED QUOTES LIST ***
        const motivationalQuotes = [
            "The mind is everything. What you think you become. - Buddha",
            "Whether you think you can, or you think you can't – you're right. - Henry Ford",
            "The only limit to our realization of tomorrow will be our doubts of today. - Franklin D. Roosevelt",
            "Your time is limited, so don't waste it living someone else's life. - Steve Jobs",
            "The trouble is, you think you have time. - Buddha",
            "Lost time is never found again. - Benjamin Franklin",
            "Time is what we want most, but what we use worst. - William Penn",
            "The purpose of life, after all, is to live it, to taste experience to the utmost, to reach out eagerly and without fear for newer and richer experience. - Eleanor Roosevelt",
            "Life is not a problem to be solved, but a reality to be experienced. - Soren Kierkegaard",
            "In the end, it's not the years in your life that count. It's the life in your years. - Abraham Lincoln",
            "Get busy living or get busy dying. - Stephen King (from The Shawshank Redemption)",
            "Very little is needed to make a happy life; it is all within yourself, in your way of thinking. - Marcus Aurelius",
            "You have power over your mind – not outside events. Realize this, and you will find strength. - Marcus Aurelius",
            "The two most important days in your life are the day you are born and the day you find out why. - Mark Twain",
            "Don't be pushed around by the fears in your mind. Be led by the dreams in your heart. - Roy T. Bennett"
        ];
        let currentQuoteIndex = -1;
        const motivationalSuffixes = [ /* ... (suffixes remain same) ... */
            "Each step forward, no matter how small, builds momentum towards the happy, healthy, and abundant life you're creating. Keep going!", "Remember why you started! Every completed task is a brick laid on the foundation of your dream life – full of joy, well-being, and success.", "You're not just checking boxes; you're actively crafting a future filled with health, wealth, and happiness. Celebrate the progress!", "This hustle is fueling your journey towards enjoying every moment, backed by fitness and financial freedom. Awesome work!", "Stay focused on the vision: a vibrant life filled with health, prosperity, and genuine enjoyment. Today's wins are paving the way!"
        ];
        let currentSuffixIndex = -1;

        // --- DOM Elements ---
        const columns = document.querySelectorAll('.kanban-column');
        const timeDateDisplay = document.getElementById('time-date-display');
        const dateSelector = document.getElementById('date-selector');
        const selectedDateDisplay = document.getElementById('selected-date-display');
        const dailySummaryDiv = document.getElementById('daily-summary');
        const summaryContentP = document.getElementById('summary-content');
        const confettiCanvas = document.getElementById('confetti-canvas');
        const quoteDisplay = document.getElementById('motivational-quote');
        const ideaTaskInput = document.getElementById('idea-task-input');
        const addIdeaTaskBtn = document.getElementById('add-idea-task-btn');
        const ideaTaskList = document.getElementById('idea-task-list');
        const timePromptModal = document.getElementById('time-prompt-modal');
        const modalTaskText = document.getElementById('modal-task-text');
        const modalStartTimeInput = document.getElementById('modal-start-time');
        const modalEndTimeInput = document.getElementById('modal-end-time');
        const modalSaveBtn = document.getElementById('modal-save-btn');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');

        // --- Confetti Setup ---
        let myConfetti = null;
        if (typeof confetti !== 'undefined') { myConfetti = confetti.create(confettiCanvas, { resize: true, useWorker: true }); }
        else { console.warn("Confetti library not loaded."); }

        // --- State ---
        let draggedElement = null;
        let draggedElementType = null;
        let currentSelectedDate = '';
        let taskCheckIntervalId = null; // For auto-move check
        let progressTimerIntervalId = null; // For updating in-progress timers
        let lastMinuteIntervalId = null; // For second-level countdown
        let ideaTaskToSchedule = null;

        // --- Utility Functions ---
        function getCurrentDateString(timeZone) { const now = new Date(); const formatter = new Intl.DateTimeFormat('en-CA', { year: 'numeric', month: '2-digit', day: '2-digit', timeZone: timeZone }); return formatter.format(now); }
        function getCurrentTimeString(timeZone) { const now = new Date(); const formatter = new Intl.DateTimeFormat('en-GB', { hour: '2-digit', minute: '2-digit', hour12: false, timeZone: timeZone }); return formatter.format(now); }
        function formatLiveDateTime(timeZone) { const now = new Date(); const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric', hour: 'numeric', minute: '2-digit', timeZoneName: 'short', timeZone: timeZone }; return now.toLocaleString('en-US', options); }
        function formatDisplayDate(dateString) { if (!dateString || !/^\d{4}-\d{2}-\d{2}$/.test(dateString)) return "Invalid Date"; const [year, month, day] = dateString.split('-'); const date = new Date(Date.UTC(Number(year), Number(month) - 1, Number(day))); const options = { year: 'numeric', month: 'long', day: 'numeric', timeZone: 'UTC' }; return date.toLocaleDateString('en-US', options); }
        function calculateDuration(startTime, endTime) { if (!startTime || !endTime) return ""; try { const start = new Date(`1970-01-01T${startTime}:00`); const end = new Date(`1970-01-01T${endTime}:00`); if (isNaN(start) || isNaN(end) || end <= start) return ""; let diffMillis = end - start; const hours = Math.floor(diffMillis / (1000 * 60 * 60)); diffMillis -= hours * (1000 * 60 * 60); const minutes = Math.floor(diffMillis / (1000 * 60)); let durationStr = ""; if (hours > 0) durationStr += `${hours}h `; if (minutes > 0) durationStr += `${minutes}m`; return durationStr.trim(); } catch (e) { console.error("Error calculating duration:", e); return ""; } }
        function formatTimeTo12Hour(timeString) { if (!timeString || !/^\d{2}:\d{2}$/.test(timeString)) { return timeString; } const [hours, minutes] = timeString.split(':'); const hourNum = parseInt(hours, 10); const ampm = hourNum >= 12 ? 'PM' : 'AM'; let hour12 = hourNum % 12; if (hour12 === 0) { hour12 = 12; } return `${hour12}:${minutes} ${ampm}`; }

        // --- Data Management Functions (Firestore - RENAMED Collections) ---

        // *** MODIFIED loadTasksFromFirestore with Detailed Error Logging ***
        async function loadTasksFromFirestore(dateString) {
            if (!db || !hustleTasksCollection) {
                const errorMsg = "Firestore 'hustle_tasks' collection not initialized when loading tasks.";
                console.error(errorMsg);
                // Display a more user-friendly message if needed, but the console error is key
                // selectedDateDisplay.textContent = "Error: Database connection issue.";
                throw new Error(errorMsg); // Throw error to be caught by caller if necessary
            }

            console.log(`Attempting to load daily tasks for date: ${dateString}...`);
            // Ensure dateString is valid before creating doc reference
            if (!dateString || typeof dateString !== 'string' || !/^\d{4}-\d{2}-\d{2}$/.test(dateString)) {
                 console.error(`Invalid dateString provided to loadTasksFromFirestore: ${dateString}`);
                 alert(`Internal Error: Invalid date format used (${dateString}). Cannot load tasks.`);
                 throw new Error(`Invalid dateString: ${dateString}`);
            }
            const docRef = hustleTasksCollection.doc(dateString);

            try {
                console.log(`Workspaceing document: ${docRef.path}`);
                const docSnap = await docRef.get();

                if (docSnap.exists()) {
                    console.log(`Document found for ${dateString}. Data:`, docSnap.data());
                    const data = docSnap.data() || {}; // Use empty object if data is null/undefined

                    // Basic validation: Ensure expected keys exist and are arrays (or default)
                    const tasks = {
                        todo: Array.isArray(data.todo) ? data.todo : [],
                        inprogress: Array.isArray(data.inprogress) ? data.inprogress : [],
                        done: Array.isArray(data.done) ? data.done : []
                    };
                    console.log(`Successfully processed tasks for ${dateString}.`);
                    return tasks;
                } else {
                    console.log(`No document found for ${dateString}, returning empty task lists.`);
                    return { todo: [], inprogress: [], done: [] }; // No tasks for this date yet
                }
            } catch (error) {
                // --- THIS IS THE CRITICAL PART ---
                console.error(`❌❌❌ ERROR loading daily tasks document for ${dateString}:`, error); // Log the full error object
                console.error("Error Code:", error.code); // Log specific code if available
                console.error("Error Message:", error.message); // Log specific message

                // Display a user-facing message, but keep it simple
                alert(`Failed to load tasks for ${formatDisplayDate(dateString)}. Check console for details (F12 -> Console).`);

                // Re-throw the error so the caller function (.e.g, displayTasksForDate) knows it failed
                throw error;
            }
        }
        // *** END MODIFIED loadTasksFromFirestore ***


        async function saveTasksToFirestore(dateString, tasksForDate) {
             if (!db || !hustleTasksCollection) { console.error("Firestore 'hustle_tasks' collection not initialized."); return; }
             if (!dateString || typeof dateString !== 'string' || !/^\d{4}-\d{2}-\d{2}$/.test(dateString)) { // Added dateString validation
                 console.error(`Invalid dateString provided to saveTasksToFirestore: ${dateString}. Aborting save.`);
                 alert(`Internal Error: Invalid date format used (${dateString}). Cannot save tasks.`);
                 return;
             }
             console.log(`Attempting to save daily tasks for ${dateString}... Data:`, tasksForDate);
             const docRef = hustleTasksCollection.doc(dateString);
             try {
                 // Use set with merge option if you only want to update fields present in tasksForDate
                 // await docRef.set(tasksForDate, { merge: true });
                 // Or use set without merge to completely overwrite the document (current behavior)
                 await docRef.set(tasksForDate);
                 console.log("Daily tasks successfully saved for date:", dateString);
             } catch (error) {
                 console.error(`❌❌❌ Error saving daily tasks for ${dateString}:`, error); // Enhanced logging
                 console.error("Error Code:", error.code);
                 console.error("Error Message:", error.message);
                 alert(`Error saving daily tasks for ${formatDisplayDate(dateString)}. Check console for details.`);
             }
         }

        async function loadIdeaTasksFromFirestore() {
            if (!db || !hustleIdeaBoxCollection) { console.error("Firestore 'hustle_ideaBoxTasks' collection not initialized when loading ideas."); return []; }
            console.log("Loading idea tasks from Firestore...");
            const ideaTasks = [];
            try {
                const querySnapshot = await hustleIdeaBoxCollection.orderBy("createdAt", "desc").get();
                querySnapshot.forEach((doc) => {
                    ideaTasks.push({ id: doc.id, ...doc.data() });
                });
                console.log(`Loaded ${ideaTasks.length} idea tasks.`);
                return ideaTasks;
            } catch (error) {
                console.error("❌❌❌ Error getting idea tasks:", error); // Enhanced logging
                console.error("Error Code:", error.code);
                console.error("Error Message:", error.message);
                if (error.code === 'unavailable') {
                    alert("Could not connect to Firestore to load ideas. Please check your internet connection.");
                } else {
                    alert("Error loading ideas. Check console for details.");
                }
                throw error; // Re-throw
            }
        }


        async function addIdeaTaskToFirestore(taskText) {
            console.log("DEBUG: Inside addIdeaTaskToFirestore, text:", taskText);
            // Explicitly check db and collection reference right before use
            if (!db) { console.error("DEBUG: Firestore DB object is not available in addIdeaTaskToFirestore."); throw new Error("Database not initialized."); }
            if (!hustleIdeaBoxCollection) { console.error("DEBUG: Firestore 'hustle_ideaBoxTasks' collection reference is not available."); throw new Error("Database collection 'hustle_ideaBoxTasks' could not be referenced."); }
            console.log("DEBUG: hustleIdeaBoxCollection reference is valid. Type:", typeof hustleIdeaBoxCollection, " Path:", hustleIdeaBoxCollection.path);

            console.log("DEBUG: Attempting Firestore add operation...");
            const dataToAdd = { text: taskText, createdAt: firebase.firestore.FieldValue.serverTimestamp() };
            console.log("DEBUG: Data to add:", dataToAdd);

            // Using await with try/catch for clearer async flow
            try {
                // *** THE ACTUAL WRITE OPERATION ***
                const docRef = await hustleIdeaBoxCollection.add(dataToAdd);
                // *** If it gets here, the write succeeded ***
                console.log("DEBUG: Firestore add operation successful (inside try). Document ID: ", docRef.id);
                return docRef.id; // Return the ID on success
            } catch (error) {
                // *** If it gets here, the write failed ***
                console.error("DEBUG: Error during Firestore add operation (inside catch): ", error);
                console.error("DEBUG: Error Code:", error.code);
                console.error("DEBUG: Error Message:", error.message);
                // Provide a more specific alert based on common errors
                if (error.code === 'permission-denied') { alert(`Error saving idea task: Permission denied. Check Firestore rules for hustle_ideaBoxTasks collection.`); }
                else { alert(`Error saving idea task: ${error.message} (Code: ${error.code}). Check console logs.`); }
                throw error; // Re-throw error so the calling function's catch block can handle it
            }
        }


        async function deleteIdeaTaskFromFirestore(taskId) {
            if (!db || !hustleIdeaBoxCollection) { console.error("Firestore 'hustle_ideaBoxTasks' collection not initialized."); throw new Error("Database not initialized for Idea Box."); }
            console.log("DEBUG: Attempting to delete idea task with ID:", taskId);
            try {
                await hustleIdeaBoxCollection.doc(taskId).delete();
                console.log("DEBUG: Idea task deleted successfully from Firestore: ", taskId);
            } catch (error) {
                console.error("DEBUG: Error deleting idea task from Firestore: ", error);
                 // Check if it's a permission error specifically
                 if (error.code === 'permission-denied') {
                    alert(`Error deleting idea task: Permission denied. Check Firestore rules allow 'delete' on hustle_ideaBoxTasks.`);
                 } else {
                    alert(`Error deleting idea task: ${error.message}. Check console.`);
                 }
                throw error; // Re-throw error
            }
        }


        // --- Core Application Functions ---
        function updateTimeDisplay() { if (timeDateDisplay) timeDateDisplay.textContent = formatLiveDateTime(BOSTON_TIMEZONE); }
        function clearBoard() { columns.forEach(column => { const tc = column.querySelector('.tasks-container'); if (tc) tc.innerHTML = ''; }); }
        function createTaskDisplayContent(taskData) { const displayWrapper = document.createElement('div'); displayWrapper.classList.add('task-content-display'); const textNode = document.createTextNode(taskData.text || 'No description'); displayWrapper.appendChild(textNode); if (taskData.startTime && taskData.endTime) { const timeInfoSpan = document.createElement('span'); timeInfoSpan.classList.add('task-time-info'); const duration = calculateDuration(taskData.startTime, taskData.endTime); const formattedStart = formatTimeTo12Hour(taskData.startTime); const formattedEnd = formatTimeTo12Hour(taskData.endTime); timeInfoSpan.innerHTML = `${formattedStart} - ${formattedEnd}` + (duration ? ` <span class="duration">(${duration})</span>` : ''); displayWrapper.appendChild(timeInfoSpan); } if (taskData.completionDate) { const dateSpan = document.createElement('span'); dateSpan.classList.add('task-completion-date'); dateSpan.textContent = `Completed: ${formatDisplayDate(taskData.completionDate)}`; displayWrapper.appendChild(dateSpan); } return displayWrapper; }
        function createTaskElement(taskData, columnId) { const taskId = taskData.firestoreId || `task-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`; const { text, startTime, endTime, completionDate } = taskData; const task = document.createElement('div'); task.classList.add('kanban-task'); task.setAttribute('draggable', 'true'); task.id = taskId; task.dataset.type = 'kanban-task'; task.dataset.text = text || ''; if (startTime) task.dataset.startTime = startTime; if (endTime) task.dataset.endTime = endTime; if (completionDate) task.dataset.completionDate = completionDate; const displayContent = createTaskDisplayContent(taskData); task.appendChild(displayContent); if (columnId === 'inprogress' && startTime && endTime) { task.appendChild(createProgressElements()); } const deleteBtn = document.createElement('button'); deleteBtn.classList.add('delete-task-btn'); deleteBtn.innerHTML = '&times;'; deleteBtn.setAttribute('aria-label', 'Delete task'); deleteBtn.onclick = async (event) => { event.stopPropagation(); if (confirm(`Delete task: "${task.dataset.text}"?`)) { task.remove(); await saveCurrentBoardState(); } }; task.appendChild(deleteBtn); task.addEventListener('dragstart', handleDragStart); task.addEventListener('dragend', handleDragEnd); task.addEventListener('dblclick', (event) => { if (event.target === deleteBtn || deleteBtn.contains(event.target)) return; enterEditMode(task); }); return task; }
        function createProgressElements() { const container = document.createElement('div'); container.classList.add('task-progress-container'); const progressBar = document.createElement('div'); progressBar.classList.add('progress-bar'); const progressBarFill = document.createElement('div'); progressBarFill.classList.add('progress-bar-fill'); progressBar.appendChild(progressBarFill); const remainingTimeSpan = document.createElement('span'); remainingTimeSpan.classList.add('remaining-time'); remainingTimeSpan.textContent = 'Calculating...'; container.appendChild(progressBar); container.appendChild(remainingTimeSpan); return container; }

        // --- Idea Box Functions ---
        function createIdeaTaskElement(ideaTaskData) {
            const { id, text } = ideaTaskData;
            const task = document.createElement('div');
            task.classList.add('idea-task');
            task.setAttribute('draggable', 'true');
            task.id = `idea-${id}`; // Use Firestore ID from data
            task.dataset.id = id; // Store Firestore ID
            task.dataset.text = text;
            task.dataset.type = 'idea-task';
            const textSpan = document.createElement('span');
            textSpan.textContent = text;
            task.appendChild(textSpan);
            const deleteBtn = document.createElement('button');
            deleteBtn.classList.add('delete-idea-task-btn');
            deleteBtn.innerHTML = '&times;';
            deleteBtn.setAttribute('aria-label', 'Delete idea task');

            // Attach the event listener correctly
            deleteBtn.addEventListener('click', async (event) => {
                event.stopPropagation(); // Prevent other listeners if needed
                 // Retrieve the ID directly from the element's dataset when clicked
                 const taskIdToDelete = task.dataset.id;
                console.log(`DEBUG: Delete button clicked for idea ID: ${taskIdToDelete}, Text: "${task.dataset.text}"`);

                if (confirm(`Are you sure you want to delete idea: "${task.dataset.text}"?`)) {
                    deleteBtn.disabled = true; // Disable button
                    try {
                        console.log(`DEBUG: Calling deleteIdeaTaskFromFirestore for ID: ${taskIdToDelete}`);
                        await deleteIdeaTaskFromFirestore(taskIdToDelete); // Call the Firestore delete function
                        console.log(`DEBUG: Firestore delete successful for ID: ${taskIdToDelete}. Removing element.`);
                        task.remove(); // Remove the element from the DOM on success
                    } catch (error) {
                        deleteBtn.disabled = false; // Re-enable on error
                        console.error("DEBUG: Failed to delete idea task (error caught in click handler):", error);
                        // Alert is handled within deleteIdeaTaskFromFirestore
                    }
                } else {
                    console.log("DEBUG: Delete confirmation cancelled.");
                }
            });

            task.appendChild(deleteBtn);
            task.addEventListener('dragstart', handleDragStart);
            task.addEventListener('dragend', handleDragEnd);
            return task;
        }


        async function displayIdeaTasks() {
            if (!ideaTaskList) return;
            ideaTaskList.innerHTML = '<p class="text-slate-400 text-center italic">Loading ideas...</p>';
            try {
                const ideaTasks = await loadIdeaTasksFromFirestore();
                ideaTaskList.innerHTML = ''; // Clear loading/previous list
                if (ideaTasks.length === 0) { ideaTaskList.innerHTML = '<p class="text-slate-400 text-center italic">No ideas captured yet. Add some!</p>'; }
                else { ideaTasks.forEach(taskData => { const taskElement = createIdeaTaskElement(taskData); ideaTaskList.appendChild(taskElement); }); }
            } catch (error) {
                 console.error("Error displaying idea tasks:", error);
                 // Error message might already be shown by loadIdeaTasksFromFirestore
                 if (ideaTaskList.innerHTML.includes('Loading')) { // Avoid duplicate error messages
                    ideaTaskList.innerHTML = '<p class="text-red-400 text-center italic">Error loading ideas. Please check connection/console.</p>';
                 }
            }
        }

        async function addIdeaTask() {
            console.log("DEBUG: addIdeaTask called"); // Log start
            if (!ideaTaskInput || !addIdeaTaskBtn) { console.error("DEBUG: Idea task input or button not found."); return; }
            const taskText = ideaTaskInput.value.trim();
            if (taskText === '') { alert('Please enter an idea description.'); ideaTaskInput.focus(); return; }

            console.log("DEBUG: Disabling button, text:", taskText);
            addIdeaTaskBtn.disabled = true; addIdeaTaskBtn.textContent = 'Adding...';

            try {
                console.log("DEBUG: Calling addIdeaTaskToFirestore...");
                const newId = await addIdeaTaskToFirestore(taskText); // Uses await/catch inside now
                console.log("DEBUG: Back from addIdeaTaskToFirestore. ID:", newId); // Will log ID if successful

                // This block only runs if addIdeaTaskToFirestore doesn't throw an error
                 // Create data object including the new ID received from Firestore
                const newTaskData = { id: newId, text: taskText, createdAt: new Date() }; // Use actual ID
                const newTaskElement = createIdeaTaskElement(newTaskData);
                const placeholder = ideaTaskList.querySelector('p');
                if (placeholder) placeholder.remove();
                ideaTaskList.prepend(newTaskElement); // Add to top of the list
                ideaTaskInput.value = ''; // Clear input ONLY on success
                console.log("DEBUG: Successfully added idea to UI:", taskText);

            } catch (error) {
                // ERROR Handling: This catches errors thrown from addIdeaTaskToFirestore
                console.error("DEBUG: Error caught in addIdeaTask's catch block:", error);
                // Alert is already handled in addIdeaTaskToFirestore's catch block
            } finally {
                // FINALLY block: Always re-enable the button and reset text
                console.log("DEBUG: Executing finally block in addIdeaTask");
                addIdeaTaskBtn.disabled = false;
                addIdeaTaskBtn.textContent = 'Add Idea';
                ideaTaskInput.focus();
            }
        }


        // --- Edit Mode Functions (Daily Tasks) ---
        function enterEditMode(taskElement) { if (taskElement.classList.contains('editing')) return; taskElement.classList.add('editing'); taskElement.setAttribute('draggable', 'false'); const displayContent = taskElement.querySelector('.task-content-display'); if (displayContent) displayContent.style.display = 'none'; const progressContainer = taskElement.querySelector('.task-progress-container'); if (progressContainer) progressContainer.style.display = 'none'; const editForm = document.createElement('div'); editForm.classList.add('task-edit-form'); const textInput = document.createElement('input'); textInput.type = 'text'; textInput.value = taskElement.dataset.text || ''; textInput.placeholder = 'Task description'; const timeInputsDiv = document.createElement('div'); timeInputsDiv.classList.add('edit-time-inputs'); const startTimeDiv = document.createElement('div'); const startTimeInput = document.createElement('input'); startTimeInput.type = 'time'; startTimeInput.value = taskElement.dataset.startTime || ''; startTimeDiv.appendChild(startTimeInput); const endTimeDiv = document.createElement('div'); const endTimeInput = document.createElement('input'); endTimeInput.type = 'time'; endTimeInput.value = taskElement.dataset.endTime || ''; endTimeDiv.appendChild(endTimeInput); timeInputsDiv.appendChild(startTimeDiv); timeInputsDiv.appendChild(endTimeDiv); const buttonsDiv = document.createElement('div'); buttonsDiv.classList.add('edit-buttons'); const saveBtn = document.createElement('button'); saveBtn.textContent = 'Save'; saveBtn.classList.add('edit-save-btn'); saveBtn.onclick = () => saveEdit(taskElement, textInput, startTimeInput, endTimeInput); const cancelBtn = document.createElement('button'); cancelBtn.textContent = 'Cancel'; cancelBtn.classList.add('edit-cancel-btn'); cancelBtn.onclick = () => cancelEdit(taskElement); buttonsDiv.appendChild(saveBtn); buttonsDiv.appendChild(cancelBtn); editForm.appendChild(textInput); editForm.appendChild(timeInputsDiv); editForm.appendChild(buttonsDiv); taskElement.appendChild(editForm); textInput.focus(); }
        function exitEditMode(taskElement) { const editForm = taskElement.querySelector('.task-edit-form'); if (editForm) editForm.remove(); const displayContent = taskElement.querySelector('.task-content-display'); if (displayContent) displayContent.style.display = ''; const progressContainer = taskElement.querySelector('.task-progress-container'); if (progressContainer) progressContainer.style.display = 'flex'; taskElement.classList.remove('editing'); taskElement.setAttribute('draggable', 'true'); }
        async function saveEdit(taskElement, textInput, startTimeInput, endTimeInput) { const newText = textInput.value.trim(); const newStartTime = startTimeInput.value; const newEndTime = endTimeInput.value; if (newText === '') { alert('Task description cannot be empty.'); textInput.focus(); return; } if (!/^\d{2}:\d{2}$/.test(newStartTime)) { alert('Please enter a valid start time (HH:MM).'); startTimeInput.focus(); return; } if (!/^\d{2}:\d{2}$/.test(newEndTime)) { alert('Please enter a valid end time (HH:MM).'); endTimeInput.focus(); return; } if (newStartTime >= newEndTime) { alert('End time must be after start time.'); endTimeInput.focus(); return; } taskElement.dataset.text = newText; taskElement.dataset.startTime = newStartTime; taskElement.dataset.endTime = newEndTime; const completionDate = taskElement.dataset.completionDate || null; const displayContent = taskElement.querySelector('.task-content-display'); if (displayContent) { while (displayContent.firstChild) { displayContent.removeChild(displayContent.firstChild); } const updatedDisplayData = { text: newText, startTime: newStartTime, endTime: newEndTime, completionDate: completionDate }; const newDisplay = createTaskDisplayContent(updatedDisplayData); while (newDisplay.firstChild) { displayContent.appendChild(newDisplay.firstChild); } } if (taskElement.closest('#inprogress')) { updateSingleTaskTimer(taskElement); } exitEditMode(taskElement); await saveCurrentBoardState(); console.log("Task edited and saved:", taskElement.id); }
        function cancelEdit(taskElement) { exitEditMode(taskElement); console.log("Task edit cancelled:", taskElement.id); }

        // --- Daily Task Board Functions ---
         // Function to display tasks for a specific date
        async function displayTasksForDate(dateString) {
            if (!db) {
                selectedDateDisplay.textContent = "Database not connected.";
                return;
            }
            currentSelectedDate = dateString;
            const formattedDate = formatDisplayDate(dateString); // Format date once
            selectedDateDisplay.textContent = `Loading tasks for ${formattedDate}...`;
            if (dateSelector) dateSelector.value = dateString;
            clearBoard(); // Clear existing tasks from the board

            try {
                // Load tasks using the potentially modified loadTasksFromFirestore
                const tasksForDay = await loadTasksFromFirestore(dateString);

                // Update display only on successful load
                selectedDateDisplay.textContent = `Showing tasks for: ${formattedDate}`;

                // Populate columns
                Object.keys(tasksForDay).forEach(columnId => {
                    const columnElement = document.getElementById(columnId);
                    const tasksContainer = columnElement?.querySelector('.tasks-container');
                    if (tasksContainer) {
                        // Clear previous tasks in this specific container before adding new ones
                        // This might be redundant if clearBoard() already does it, but ensures clean state
                        // tasksContainer.innerHTML = '';
                        tasksForDay[columnId].forEach(taskData => {
                            const taskElement = createTaskElement(taskData, columnId);
                            tasksContainer.appendChild(taskElement);
                        });
                    } else {
                        console.warn(`Tasks container not found in column "${columnId}".`);
                    }
                });

                checkAndMoveTasks(); // Check if any tasks need moving based on time
                updateInProgressTimers(); // Update timers for tasks in progress

            } catch (error) {
                // Error is now logged in detail within loadTasksFromFirestore
                console.error("Error caught by displayTasksForDate:", error);
                // Update display to show the date, but indicate failure (alert already shown)
                selectedDateDisplay.textContent = `Showing tasks for: ${formattedDate} (Load Failed)`;
                // Do not proceed with checkAndMoveTasks or updateInProgressTimers if load failed
            }
        }

        async function saveCurrentBoardState() {
             if (!db || !hustleTasksCollection) { console.error("Firestore 'hustle_tasks' collection not initialized."); return; }
             if (!currentSelectedDate) { console.log("No date selected, cannot save daily state."); return; }
             const tasksForCurrentDate = { todo: [], inprogress: [], done: [] };
             columns.forEach(column => {
                 const columnId = column.id;
                 const tasksContainer = column.querySelector('.tasks-container');
                 if (tasksForCurrentDate.hasOwnProperty(columnId) && tasksContainer) {
                     tasksContainer.querySelectorAll('.kanban-task').forEach(task => {
                         if (task.classList.contains('editing')) {
                             console.warn("Skipping save for task in edit mode:", task.id);
                             return; // Don't save task being edited
                         }
                         const taskData = {
                             text: task.dataset.text || '',
                             startTime: task.dataset.startTime || null,
                             endTime: task.dataset.endTime || null,
                             // Retrieve completion date carefully
                             completionDate: task.dataset.completionDate && task.dataset.completionDate !== 'null' ? task.dataset.completionDate : null
                         };
                         // Only save tasks that have text content
                         if (taskData.text) {
                             tasksForCurrentDate[columnId].push(taskData);
                         } else {
                             console.warn("Skipping saving daily task with no text:", task.id);
                         }
                     });
                 } else if (!tasksContainer) {
                     console.warn(`Tasks container not found in column "${columnId}" during save.`);
                 }
             });

             // Call the potentially modified save function
             await saveTasksToFirestore(currentSelectedDate, tasksForCurrentDate);
         }

        async function addTask() {
            if (!db || !hustleTasksCollection) { alert("Database not connected. Cannot add task."); return; }
            const taskInput = document.getElementById('new-task-input');
            const startTimeInput = document.getElementById('new-task-start-time');
            const endTimeInput = document.getElementById('new-task-end-time');
            const todoColumn = document.getElementById('todo');
            const todoTasksContainer = todoColumn?.querySelector('.tasks-container');
            if (!taskInput || !startTimeInput || !endTimeInput || !todoTasksContainer) { console.error("Error: Daily task form/column elements not found."); alert("Error: Could not find necessary form elements."); return; }
            const taskText = taskInput.value.trim();
            const startTime = startTimeInput.value;
            const endTime = endTimeInput.value;
            if (taskText === '') { alert('Please enter a task description.'); taskInput.focus(); return; }
            if (!startTime) { alert('Please enter a start time.'); startTimeInput.focus(); return; }
            if (!endTime) { alert('Please enter an end time.'); endTimeInput.focus(); return; }
            if (startTime >= endTime) { alert('End time must be after start time.'); endTimeInput.focus(); return; }
            if (!currentSelectedDate) { alert('Please select a date first.'); return; }
            const newTaskData = { text: taskText, startTime: startTime, endTime: endTime, completionDate: null };
            const newTaskElement = createTaskElement(newTaskData, 'todo');
            if (newTaskElement) {
                todoTasksContainer.appendChild(newTaskElement);
            } else {
                console.error("Error creating daily task element.");
                alert("Error: Could not create the task visually.");
                return;
            }
            taskInput.value = ''; startTimeInput.value = ''; endTimeInput.value = '';
            await saveCurrentBoardState(); // Save the updated board state
            console.log(`Daily task added locally for "${taskText}", saving board state.`);
            checkAndMoveTasks(); // Check if the new task should move immediately
        }


        // --- Drag and Drop Event Handlers ---
        function handleDragStart(event) { if (event.target.classList.contains('kanban-task') && event.target.classList.contains('editing')) { event.preventDefault(); return; } draggedElement = event.target; draggedElementType = event.target.dataset.type; event.dataTransfer.setData('text/plain', event.target.id); event.dataTransfer.effectAllowed = "move"; setTimeout(() => { if (draggedElement) draggedElement.classList.add('dragging'); }, 0); console.log(`Drag Start: ${draggedElementType} - ${draggedElement.id}`); }
        function handleDragEnd() { if (draggedElement) { draggedElement.classList.remove('dragging'); console.log(`Drag End: ${draggedElementType} - ${draggedElement.id}`); } draggedElement = null; draggedElementType = null; columns.forEach(col => col.classList.remove('drag-over')); }
        function handleDragOver(event) { event.preventDefault(); const targetColumn = event.target.closest('.kanban-column'); const targetTask = event.target.closest('.kanban-task, .idea-task'); if (targetTask && targetTask.classList.contains('editing')) { event.dataTransfer.dropEffect = "none"; return; } if (draggedElementType === 'idea-task' && targetColumn && (targetColumn.id === 'inprogress' || targetColumn.id === 'done')) { event.dataTransfer.dropEffect = "none"; return; } event.dataTransfer.dropEffect = "move"; if (targetColumn && !targetColumn.classList.contains('drag-over')) { columns.forEach(col => col.classList.remove('drag-over')); targetColumn.classList.add('drag-over'); } }
        function handleDragLeave(event) { const targetColumn = event.target.closest('.kanban-column'); if (targetColumn && !targetColumn.contains(event.relatedTarget)) { targetColumn.classList.remove('drag-over'); } }
        async function handleDrop(event) { event.preventDefault(); const targetColumn = event.target.closest('.kanban-column'); const targetTasksContainer = targetColumn?.querySelector('.tasks-container'); const targetElement = event.target.closest('.kanban-task, .idea-task'); targetColumn?.classList.remove('drag-over'); if (!targetColumn || !targetTasksContainer || !draggedElement || !draggedElementType) { console.warn("Drop cancelled: Invalid target or no dragged element."); return; } if (targetElement && targetElement.classList.contains('editing')) { console.warn("Drop cancelled: Target element is being edited."); return; } if (draggedElementType === 'idea-task' && (targetColumn.id === 'inprogress' || targetColumn.id === 'done')) { console.warn("Drop cancelled: Idea tasks can only be dropped onto 'To Do'."); return; } if (draggedElement === targetElement) { console.warn("Drop cancelled: Dropped onto self."); return; } console.log(`Drop detected: ${draggedElementType} onto ${targetColumn.id}`); if (draggedElementType === 'idea-task' && targetColumn.id === 'todo') { ideaTaskToSchedule = { id: draggedElement.dataset.id, text: draggedElement.dataset.text }; showTimePrompt(ideaTaskToSchedule.text); } else if (draggedElementType === 'kanban-task') { const previousColumn = draggedElement.parentElement.closest('.kanban-column'); let completionDate = draggedElement.dataset.completionDate || null; if (previousColumn?.id === 'inprogress' && targetColumn.id !== 'inprogress') { const progressContainer = draggedElement.querySelector('.task-progress-container'); if (progressContainer) progressContainer.remove(); } if (targetColumn.id !== 'done') { const existingDateSpan = draggedElement.querySelector('.task-completion-date'); if (existingDateSpan) existingDateSpan.remove(); delete draggedElement.dataset.completionDate; completionDate = null; } if (targetColumn.id === 'done') { if (!completionDate) { completionDate = getCurrentDateString(BOSTON_TIMEZONE); draggedElement.dataset.completionDate = completionDate; } const existingDateSpan = draggedElement.querySelector('.task-completion-date'); if (existingDateSpan) existingDateSpan.remove(); const dateSpan = document.createElement('span'); dateSpan.classList.add('task-completion-date'); dateSpan.textContent = `Completed: ${formatDisplayDate(completionDate)}`; const timeInfo = draggedElement.querySelector('.task-time-info'); const displayContent = draggedElement.querySelector('.task-content-display'); if (timeInfo) { timeInfo.insertAdjacentElement('afterend', dateSpan); } else if (displayContent) { displayContent.appendChild(dateSpan); } if (previousColumn && previousColumn.id !== 'done' && myConfetti) { triggerConfetti(); } } if (targetColumn.id === 'inprogress' && previousColumn?.id !== 'inprogress') { if (draggedElement.dataset.startTime && draggedElement.dataset.endTime) { if (!draggedElement.querySelector('.task-progress-container')) { draggedElement.appendChild(createProgressElements()); } updateSingleTaskTimer(draggedElement); } } if (targetElement && targetTasksContainer.contains(targetElement)) { targetTasksContainer.insertBefore(draggedElement, targetElement); } else { targetTasksContainer.appendChild(draggedElement); } await saveCurrentBoardState(); updateInProgressTimers(); } }

        // --- Time Prompt Modal Functions ---
        function showTimePrompt(taskText) { if (!timePromptModal || !modalTaskText || !modalStartTimeInput || !modalEndTimeInput) return; modalTaskText.textContent = `Scheduling: "${taskText}"`; modalStartTimeInput.value = ''; modalEndTimeInput.value = ''; timePromptModal.classList.add('active'); modalStartTimeInput.focus(); }
        function hideTimePrompt() { if (!timePromptModal) return; timePromptModal.classList.remove('active'); ideaTaskToSchedule = null; modalStartTimeInput.value = ''; modalEndTimeInput.value = ''; }
        async function handleModalSave() { if (!ideaTaskToSchedule || !modalStartTimeInput || !modalEndTimeInput) { console.error("Cannot save modal: Missing task data or input elements."); hideTimePrompt(); return; } const startTime = modalStartTimeInput.value; const endTime = modalEndTimeInput.value; if (!startTime) { alert('Please enter a start time.'); modalStartTimeInput.focus(); return; } if (!endTime) { alert('Please enter an end time.'); modalEndTimeInput.focus(); return; } if (startTime >= endTime) { alert('End time must be after start time.'); modalEndTimeInput.focus(); return; } if (!currentSelectedDate) { alert('Cannot schedule task: No date selected.'); hideTimePrompt(); return; } const newTaskData = { text: ideaTaskToSchedule.text, startTime: startTime, endTime: endTime, completionDate: null }; const newTaskElement = createTaskElement(newTaskData, 'todo'); const todoColumn = document.getElementById('todo'); const todoTasksContainer = todoColumn?.querySelector('.tasks-container'); if (newTaskElement && todoTasksContainer) { todoTasksContainer.appendChild(newTaskElement); await saveCurrentBoardState(); console.log(`Scheduled idea task "${newTaskData.text}" for ${currentSelectedDate}`); hideTimePrompt(); } else { console.error("Error creating or appending scheduled task element."); alert("Error adding scheduled task to the board."); hideTimePrompt(); } }

        // --- Other Core Functions ---
        function triggerConfetti() { if (!myConfetti) return; myConfetti({ particleCount: 200, spread: 100, origin: { y: 0.6 }, colors: ['#f97316', '#ef4444', '#facc15', '#ffffff', '#a855f7'] }); }
        async function archiveTaskToFirestore(taskData) { if (!db || !hustleArchiveCollection) { console.error("Firestore 'hustle_archive' collection not initialized."); return; } if (!taskData.completionDate || !taskData.text) { console.warn("Skipping archive for task missing completion date or text:", taskData); return; } const archiveData = { ...taskData, archivedAt: firebase.firestore.FieldValue.serverTimestamp() }; try { await hustleArchiveCollection.add(archiveData); console.log("Task archived to Firestore:", taskData.text); } catch (error) { console.error("Error archiving task to Firestore:", error); } }
        async function runArchivingProcess() { if (!db || !hustleTasksCollection || !hustleArchiveCollection) { console.error("Firestore not initialized. Skipping archiving."); return false; } const todayDateStr = getCurrentDateString(BOSTON_TIMEZONE); let tasksArchived = false; console.log("Running archiving process..."); try { const querySnapshot = await hustleTasksCollection.where(firebase.firestore.FieldPath.documentId(), "<", todayDateStr).get(); if (querySnapshot.empty) { console.log("No past dates found with tasks to archive."); return false; } const batch = db.batch(); const archivePromises = []; querySnapshot.forEach(doc => { const dateString = doc.id; const tasksForDay = doc.data(); let dayWasModified = false; if (tasksForDay.done && Array.isArray(tasksForDay.done) && tasksForDay.done.length > 0) { const tasksToKeepInDone = []; const tasksToArchive = []; tasksForDay.done.forEach(taskData => { if (taskData.completionDate) { tasksToArchive.push(taskData); tasksArchived = true; dayWasModified = true; } else { tasksToKeepInDone.push(taskData); console.warn(`Task in 'done' column for ${dateString} lacks completion date:`, taskData.text); } }); if (dayWasModified) { tasksToArchive.forEach(taskData => { archivePromises.push(archiveTaskToFirestore(taskData)); }); const docRef = hustleTasksCollection.doc(dateString); batch.update(docRef, { done: tasksToKeepInDone }); console.log(`Marked document ${dateString} for update in batch (removing archived tasks).`); } } }); await batch.commit(); console.log("Batch update committed successfully."); await Promise.allSettled(archivePromises); console.log("Individual archive operations settled."); } catch (error) { console.error("Error during archiving process query or batch commit:", error); } console.log(`Archiving process finished. Tasks archived: ${tasksArchived}`); return tasksArchived; }
        function generateSummaryText(tasks) { let taskSummary; if (!tasks || tasks.length === 0) { taskSummary = "Looks like there were no completed tasks logged for the previous day."; } else { const taskTexts = tasks.map(t => t.text || 'Unnamed Task'); taskSummary = `Yesterday, you crushed ${tasks.length} task(s): `; if (taskTexts.length === 1) { taskSummary += `<strong>${taskTexts[0]}</strong>.`; } else if (taskTexts.length === 2) { taskSummary += `<strong>${taskTexts[0]}</strong> and <strong>${taskTexts[1]}</strong>.`; } else { const lastTask = taskTexts.pop(); taskSummary += `<strong>${taskTexts.join('</strong>, <strong>')}</strong>, and <strong>${lastTask}</strong>.`; } } if (motivationalSuffixes.length > 0) { currentSuffixIndex = (currentSuffixIndex + 1) % motivationalSuffixes.length; taskSummary += `<span class="motivation-suffix">${motivationalSuffixes[currentSuffixIndex]}</span>`; } else { taskSummary += `<span class="motivation-suffix">Keep up the great work!</span>`; } return taskSummary; }
        async function displayLatestSummary() { if (!db || !hustleArchiveCollection) { console.error("Firestore 'hustle_archive' collection not initialized."); dailySummaryDiv.classList.add('hidden'); return; } console.log("Fetching previous day's summary..."); const today = new Date(); const yesterday = new Date(today); yesterday.setDate(today.getDate() - 1); const yesterdayDateStr = new Intl.DateTimeFormat('en-CA', { year: 'numeric', month: '2-digit', day: '2-digit', timeZone: BOSTON_TIMEZONE }).format(yesterday); try { const querySnapshot = await hustleArchiveCollection.where("completionDate", "==", yesterdayDateStr).get(); const tasksForYesterday = []; querySnapshot.forEach(doc => { tasksForYesterday.push(doc.data()); }); summaryContentP.innerHTML = generateSummaryText(tasksForYesterday); const summaryTitle = dailySummaryDiv.querySelector('h3'); if (summaryTitle) summaryTitle.textContent = `Daily Wins Recap for ${formatDisplayDate(yesterdayDateStr)}!`; dailySummaryDiv.classList.remove('hidden'); console.log(`Displaying summary for ${yesterdayDateStr} with ${tasksForYesterday.length} tasks.`); } catch (error) { console.error("Error fetching archived tasks for summary:", error); summaryContentP.innerHTML = "Could not load previous day's summary."; const summaryTitle = dailySummaryDiv.querySelector('h3'); if (summaryTitle) summaryTitle.textContent = `Daily Wins Recap`; dailySummaryDiv.classList.remove('hidden'); } }
        async function checkAndMoveTasks() { if (!db) return; const todayDateStr = getCurrentDateString(BOSTON_TIMEZONE); if (currentSelectedDate !== todayDateStr) { return; } const currentTimeStr = getCurrentTimeString(BOSTON_TIMEZONE); const todoCol = document.getElementById('todo'); const inProgressCol = document.getElementById('inprogress'); if (!todoCol || !inProgressCol) { console.error("Cannot find columns for auto-move."); return; } const todoTasksContainer = todoCol.querySelector('.tasks-container'); const inProgressTasksContainer = inProgressCol.querySelector('.tasks-container'); if (!todoTasksContainer || !inProgressTasksContainer) { console.error("Cannot find task containers for auto-move."); return; } const tasksInTodo = todoTasksContainer.querySelectorAll('.kanban-task'); let taskMoved = false; tasksInTodo.forEach(task => { if (task.classList.contains('editing')) { return; } const taskStartTime = task.dataset.startTime; if (taskStartTime && currentTimeStr >= taskStartTime) { console.log(`Auto-moving task "${task.dataset.text}" (ID: ${task.id})`); if (task.dataset.startTime && task.dataset.endTime && !task.querySelector('.task-progress-container')) { task.appendChild(createProgressElements()); } inProgressTasksContainer.appendChild(task); taskMoved = true; task.classList.add('task-just-moved'); setTimeout(() => { task.classList.remove('task-just-moved'); }, 1800); } }); if (taskMoved) { await saveCurrentBoardState(); updateInProgressTimers(); } }
        function displayMotivationalQuote() { if (!quoteDisplay || motivationalQuotes.length === 0) return; let randomIndex; if (motivationalQuotes.length > 1) { do { randomIndex = Math.floor(Math.random() * motivationalQuotes.length); } while (randomIndex === currentQuoteIndex); } else { randomIndex = 0; } currentQuoteIndex = randomIndex; quoteDisplay.textContent = motivationalQuotes[currentQuoteIndex]; }

        // --- In Progress Timer Update Functions ---
        function updateSingleTaskTimer(taskElement) { const progressBarFill = taskElement.querySelector('.progress-bar-fill'); const remainingTimeSpan = taskElement.querySelector('.remaining-time'); const startTimeStr = taskElement.dataset.startTime; const endTimeStr = taskElement.dataset.endTime; if (!progressBarFill || !remainingTimeSpan || !startTimeStr || !endTimeStr) { return Infinity; } try { const now = new Date(); const startDate = new Date(`${currentSelectedDate}T${startTimeStr}:00`); const endDate = new Date(`${currentSelectedDate}T${endTimeStr}:00`); if (isNaN(startDate) || isNaN(endDate) || endDate <= startDate) { remainingTimeSpan.textContent = 'Invalid Time'; progressBarFill.style.width = '0%'; return Infinity; } const totalDurationMillis = endDate - startDate; const elapsedMillis = now - startDate; const remainingMillis = endDate - now; let percentage = (elapsedMillis / totalDurationMillis) * 100; percentage = Math.max(0, Math.min(100, percentage)); progressBarFill.style.width = `${percentage}%`; const remainingSecondsTotal = Math.round(remainingMillis / 1000); remainingTimeSpan.classList.toggle('expired', remainingSecondsTotal < 0); if (remainingSecondsTotal < 0) { remainingTimeSpan.textContent = 'Time Up!'; } else if (remainingSecondsTotal < 60) { remainingTimeSpan.textContent = `${remainingSecondsTotal}s left`; } else { const remainingMinutes = Math.ceil(remainingSecondsTotal / 60); remainingTimeSpan.textContent = `${remainingMinutes}m left`; } return remainingSecondsTotal; } catch (e) { console.error("Error updating timer for task:", taskElement.id, e); remainingTimeSpan.textContent = 'Error'; progressBarFill.style.width = '0%'; return Infinity; } }
        function updateInProgressTimers() { const inProgressColumn = document.getElementById('inprogress'); const tasksContainer = inProgressColumn?.querySelector('.tasks-container'); if (!tasksContainer) return; const tasks = tasksContainer.querySelectorAll('.kanban-task'); let isInLastMinute = false; tasks.forEach(task => { if (task.dataset.startTime && task.dataset.endTime && !task.querySelector('.task-progress-container')) { task.appendChild(createProgressElements()); } const remainingSeconds = updateSingleTaskTimer(task); if (remainingSeconds >= 0 && remainingSeconds < 60) { isInLastMinute = true; } }); if (isInLastMinute && !lastMinuteIntervalId) { clearInterval(progressTimerIntervalId); progressTimerIntervalId = null; lastMinuteIntervalId = setInterval(updateInProgressTimers, LAST_MINUTE_INTERVAL); console.log("Starting last minute timer interval."); } else if (!isInLastMinute && lastMinuteIntervalId) { clearInterval(lastMinuteIntervalId); lastMinuteIntervalId = null; if (!progressTimerIntervalId) { progressTimerIntervalId = setInterval(updateInProgressTimers, TIMER_UPDATE_INTERVAL); console.log("Stopping last minute timer, restarting regular interval."); } } }

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', async () => {
            console.log("DOM fully loaded and parsed.");
            updateTimeDisplay(); setInterval(updateTimeDisplay, 60000);
            displayMotivationalQuote();

            // Check for DB connection before proceeding
            if (!db) {
                console.error("DB not initialized. Aborting further setup.");
                if(selectedDateDisplay) selectedDateDisplay.textContent = "Database Connection Failed! Check Config.";
                // Disable interactive elements if DB fails
                document.querySelectorAll('button, input').forEach(el => el.disabled = true);
                return; // Stop initialization
            }

            console.log("Database connection available. Proceeding...");

            try { await runArchivingProcess(); } catch (error) { console.error("Error during initial archiving:", error); }

            // Load ideas first, handle potential errors
             try {
                 await displayIdeaTasks();
             } catch(error) {
                 // Error is logged within loadIdeaTasksFromFirestore now
                 console.error("Failed initial idea task load (caught in DOMContentLoaded):", error);
             }


            // Load today's tasks
            const currentBostonDate = getCurrentDateString(BOSTON_TIMEZONE);
            if (dateSelector) {
                dateSelector.value = currentBostonDate;
                try {
                    await displayTasksForDate(currentBostonDate); // Load today's tasks
                } catch (error) {
                    // Error is logged within loadTasksFromFirestore and handled in displayTasksForDate
                    console.error("Failed initial daily task load (caught in DOMContentLoaded):", error);
                }
                 // Add listener *after* initial load attempt
                dateSelector.addEventListener('change', (event) => { displayTasksForDate(event.target.value); });
            } else {
                console.error("Date selector element not found.");
                try { await displayTasksForDate(currentBostonDate); } catch (error) { /* Handled in displayTasksForDate */ }
            }

            // Load summary
            try { await displayLatestSummary(); } catch(error) { console.error("Failed to display latest summary:", error); }

            // --- Event Listeners ---
            const addTaskBtnLocal = document.getElementById('add-task-btn'); if (addTaskBtnLocal) { addTaskBtnLocal.addEventListener('click', addTask); const dailyTaskInputs = ['new-task-input', 'new-task-start-time', 'new-task-end-time']; dailyTaskInputs.forEach(id => { const input = document.getElementById(id); if (input) input.addEventListener('keypress', (event) => { if (event.key === 'Enter') addTask(); }); }); } else { console.error("Add daily task button not found."); }
            if (addIdeaTaskBtn && ideaTaskInput) { addIdeaTaskBtn.addEventListener('click', addIdeaTask); ideaTaskInput.addEventListener('keypress', (event) => { if (event.key === 'Enter') addIdeaTask(); }); } else { console.error("Add idea task button or input not found."); }
            if (modalSaveBtn) modalSaveBtn.addEventListener('click', handleModalSave); if (modalCancelBtn) modalCancelBtn.addEventListener('click', hideTimePrompt);

            // Start Auto-Move Check Interval
            if (taskCheckIntervalId) clearInterval(taskCheckIntervalId); taskCheckIntervalId = setInterval(checkAndMoveTasks, TASK_CHECK_INTERVAL); console.log(`Started task check interval (${TASK_CHECK_INTERVAL / 1000}s). ID: ${taskCheckIntervalId}`);
            // Start In-Progress Timer Update Interval
            if (progressTimerIntervalId) clearInterval(progressTimerIntervalId); if (lastMinuteIntervalId) clearInterval(lastMinuteIntervalId); progressTimerIntervalId = setInterval(updateInProgressTimers, TIMER_UPDATE_INTERVAL); console.log(`Started progress timer interval (${TIMER_UPDATE_INTERVAL / 1000}s). ID: ${progressTimerIntervalId}`);
            console.log("Initialization complete.");
        });
    </script>

</body>
</html>
