<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SNG's Funky 3D Hustle Board</title>

    <!-- GitHub Pages PWA Fix for standalone mode -->
    <script type="text/javascript">
        (function() {
            // If the app is being launched as a PWA
            if (window.matchMedia('(display-mode: standalone)').matches) {
                var l = window.location;
                var redirectURL = l.protocol + '//' + l.hostname + (l.port ? ':' + l.port : '') + '/';
                
                // If we're in a subfolder of the GitHub repo, add it to the path
                var pathParts = l.pathname.split('/');
                if (pathParts.length > 2 && pathParts[1] !== "") {
                    redirectURL += pathParts[1] + '/';
                }
                
                // Only redirect if we're at a GitHub 404 page
                if (document.title.includes("404") || l.pathname.includes("/404.html") || 
                    l.search.includes('?p=/')) {
                    window.location.replace(redirectURL);
                }
            }
        })();
    </script>

    <!-- PWA Support -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="SNG Board">
    <link rel="apple-touch-icon" href="icon-192.png"> 
    <meta name="theme-color" content="#f97316">
    <link rel="manifest" href="manifest.json">
    <link rel="shortcut icon" href="icon-192.png">

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.6.7/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.7/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.7/firebase-auth-compat.js"></script>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Confetti Library -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/dist/confetti.browser.min.js"></script>

    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Poppins:wght@700;800&display=swap" rel="stylesheet">

    <style>
        /* --- CSS Styles --- */
        :root {
            /* Color variables */
            --column-bg: rgba(17, 24, 39, 0.75); --column-header-text: #f1f5f9;
            --task-bg: #ffffff; --task-text: #1f2937;
            --idea-task-bg: #e2e8f0; --idea-task-text: #334155;
            --accent-todo: #f59e0b; --accent-inprogress: #eab308; --accent-done: #22c55e;
            --button-primary-bg: #dc2626; --button-primary-hover: #b91c1c;
            --button-secondary-bg: #16a34a; --button-secondary-hover: #15803d;
            --button-cancel-bg: #64748b; --button-cancel-hover: #475569;
            --quote-bg: rgba(255, 255, 255, 0.1); --quote-border: rgba(255, 255, 255, 0.3); --quote-text: #f8fafc;
            --summary-bg: rgba(30, 41, 59, 0.8); --summary-header: #facc15; --summary-text: #cbd5e1; --summary-strong: #fde047;
            --idea-box-bg: rgba(51, 65, 85, 0.8);
            --modal-bg: rgba(17, 24, 39, 0.9); --modal-content-bg: #1f2937;
            --progress-bar-bg: #e5e7eb; /* gray-200 */
            --progress-bar-fill: var(--accent-inprogress); /* Use in-progress accent */
            --timer-text-color: #4b5563; /* gray-600 */
            --timer-text-expired-color: #dc2626; /* red-600 */
        }

        body {
            font-family: 'Inter', sans-serif;
            background-image: url('https://raw.githubusercontent.com/sniting/sng-hustle-board./main/ChatGPT%20Image%20Apr%2030%2C%202025%20at%2007_19_36%20PM.png');
            background-size: cover; background-position: center center; background-repeat: no-repeat; background-attachment: fixed;
            background-color: #374151; /* Fallback color */
            padding: 2rem 1rem 5rem 1rem; color: var(--column-header-text);
            perspective: 1800px; overflow-x: hidden; min-height: 100vh;
        }
        h1, h2, h3 { font-family: 'Poppins', sans-serif; font-weight: 800; letter-spacing: 0.02em; }
        #main-content-wrapper { max-width: 1200px; margin: 0 auto; }
        #main-title { color: #ffffff; text-shadow: 2px 2px 4px rgba(0,0,0,0.6); animation: pulse-glow 3s infinite alternate; }
        #subtitle { color: #f1f5f9; text-shadow: 1px 1px 3px rgba(0,0,0,0.5); }
        @keyframes pulse-glow { from { text-shadow: 2px 2px 4px rgba(0,0,0,0.5), 0 0 5px rgba(255,255,255,0.3); } to { text-shadow: 2px 2px 6px rgba(0,0,0,0.6), 0 0 15px rgba(255,255,255,0.5); } }

        /* Kanban Column Styling */
        .kanban-column {
            min-height: 350px; background-color: var(--column-bg); backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 0.75rem; padding: 1.25rem;
            transition: all 0.35s cubic-bezier(0.25, 0.8, 0.25, 1); box-shadow: 0 10px 20px rgba(0, 0, 0, 0.25);
            transform: rotateX(2deg) rotateY(-1deg); display: flex; flex-direction: column;
        }
        .kanban-column:hover { transform: rotateX(0deg) rotateY(0deg) scale(1.03) translateZ(20px); box-shadow: 0 15px 35px rgba(0, 0, 0, 0.35); }
        .kanban-column h2 {
            color: var(--column-header-text); text-transform: uppercase; font-weight: 700; display: flex;
            align-items: center; justify-content: center; gap: 0.6rem; border-bottom: 2px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 0.75rem; margin-bottom: 1.25rem; flex-shrink: 0;
        }
        .tasks-container { flex-grow: 1; overflow-y: auto; min-height: 100px; padding-top: 5px; }

        /* Task Card Styling (Daily Tasks) */
        .kanban-task {
            background-color: var(--task-bg); color: var(--task-text); border-radius: 0.5rem;
            padding: 0.8rem 1.1rem; margin-bottom: 1rem; cursor: grab; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            transition: all 0.25s ease-in-out; word-break: break-word; position: relative;
            border-left: 5px solid var(--accent-todo);
        }
        #inprogress .kanban-task { border-left-color: var(--accent-inprogress); }
        #done .kanban-task { border-left-color: var(--accent-done); }

        .task-content-display {}
        .task-time-info { font-size: 0.8rem; color: #475569; margin-top: 0.4rem; display: block; font-weight: 600; }
        .task-time-info .duration { color: #57534e; margin-left: 0.5rem; font-weight: 500; }
        .task-completion-date { font-size: 0.75rem; color: #64748b; margin-top: 0.25rem; display: block; }

        /* In Progress Timer/Progress Bar Styles */
        .task-progress-container { margin-top: 0.75rem; height: 16px; display: flex; align-items: center; gap: 0.5rem; }
        .progress-bar { flex-grow: 1; height: 8px; background-color: var(--progress-bar-bg); border-radius: 4px; overflow: hidden; }
        .progress-bar-fill { height: 100%; width: 0%; background-color: var(--progress-bar-fill); border-radius: 4px; transition: width 0.5s ease-out; }
        .remaining-time { font-size: 0.75rem; font-weight: 500; color: var(--timer-text-color); white-space: nowrap; flex-shrink: 0; }
        .remaining-time.expired { color: var(--timer-text-expired-color); font-weight: 700; }

        .kanban-task:active:not(.editing) { cursor: grabbing; box-shadow: 0 8px 16px rgba(0, 0, 0, 0.15); transform: scale(1.03); }
        .dragging { opacity: 0.5; transform: rotate(5deg) scale(1.08) skew(-5deg, -2deg); }
        .idea-task.dragging { background-color: #a7f3d0; border: 1px dashed #059669; }
        .drag-over { background-color: rgba(70, 88, 116, 0.8); transform: scale(1.01); }

        /* Confetti Canvas Styling */
        #confetti-canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 9999; }

        /* Time/Date/Quote Display Styling */
        #time-date-display, #selected-date-display, #motivational-quote { background-color: rgba(30, 41, 59, 0.6); backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.2); padding: 0.8rem 1.2rem; border-radius: 0.6rem; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15); text-align: center; margin-bottom: 1.5rem; max-width: 550px; margin-left: auto; margin-right: auto; color: #f1f5f9; font-weight: 600; text-shadow: 1px 1px 2px rgba(0,0,0,0.3); transition: all 0.3s ease-out; }
        #time-date-display:hover, #selected-date-display:hover, #motivational-quote:hover { transform: translateY(-4px) scale(1.02); box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2); }
        #selected-date-display { background-color: rgba(51, 65, 85, 0.7); color: #ffffff; font-weight: 700; margin-top: 0.5rem; border-color: rgba(255, 255, 255, 0.3); }
        #motivational-quote { background-color: rgba(17, 24, 39, 0.65); border: 1px solid var(--quote-border); color: var(--quote-text); padding: 1rem 1.2rem; font-size: 1rem; font-weight: 500; font-style: normal; text-shadow: 1px 1px 2px rgba(0,0,0,0.4); margin-bottom: 2rem; }

        /* Date Selector Styling */
        #date-selector-container { text-align: center; margin-bottom: 1.5rem; }
        #date-selector-container label { margin-right: 0.5rem; font-weight: 700; color: #f1f5f9; text-shadow: 1px 1px 2px rgba(0,0,0,0.3); }
        #date-selector { padding: 0.6rem 0.8rem; border: 1px solid rgba(255,255,255,0.3); border-radius: 0.5rem; box-shadow: inset 0 1px 3px 0 rgba(0,0,0,0.1); cursor: pointer; background-color: rgba(30, 41, 59, 0.7); color: #ffffff; font-weight: 500; }

        /* Add Task Form Container Styling */
         #add-task-form-container { background-color: rgba(30, 41, 59, 0.85); backdrop-filter: blur(12px); border: 1px solid rgba(255, 255, 255, 0.2); padding: 1.75rem; border-radius: 0.75rem; box-shadow: 0 8px 20px rgba(0, 0, 0, 0.25); transition: all 0.35s cubic-bezier(0.25, 0.8, 0.25, 1); transform: rotateX(1deg) rotateY(1deg); margin-bottom: 2.5rem; }
         #add-task-form-container:hover { transform: rotateX(0deg) rotateY(0deg) scale(1.02) translateZ(15px); box-shadow: 0 12px 25px rgba(0, 0, 0, 0.3); }
        #add-task-form { display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; align-items: end; }
        #add-task-form > div:nth-child(1) { grid-column: span 2; }
        #add-task-form > div:nth-child(4) { grid-column: span 2; margin-top: 0.5rem; }
        @media (min-width: 768px) { #add-task-form { grid-template-columns: minmax(150px, 3fr) 1fr 1fr auto; gap: 1rem; } #add-task-form > div:nth-child(1) { grid-column: auto; } #add-task-form > div:nth-child(4) { grid-column: auto; margin-top: 0; } }
        #add-task-form label { display: block; font-size: 0.9rem; font-weight: 600; color: #cbd5e1; margin-bottom: 0.4rem; }
        #add-task-form input[type="text"], #add-task-form input[type="time"] { width: 100%; border: 1px solid #475569; border-radius: 0.5rem; padding: 0.6rem 0.9rem; box-shadow: inset 0 1px 3px 0 rgba(0,0,0,0.1); font-size: 0.9rem; background-color: #1e293b; color: #f1f5f9; }
        #add-task-form button { background-color: var(--button-primary-bg); color: white; font-weight: 700; padding: 0.6rem 1.5rem; border-radius: 0.5rem; transition: all 0.2s ease-in-out; box-shadow: 0 3px 6px rgba(0,0,0,0.15); border: none; cursor: pointer; text-transform: uppercase; }
        #add-task-form button:hover { background-color: var(--button-primary-hover); transform: translateY(-2px) scale(1.02); box-shadow: 0 5px 10px rgba(0,0,0,0.2); }

        /* Idea Box Styling */
        #idea-box-container { background-color: var(--idea-box-bg); backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 0.75rem; padding: 1.5rem; margin-top: 2.5rem; margin-bottom: 2.5rem; max-width: 6xl; margin-left: auto; margin-right: auto; box-shadow: 0 6px 15px rgba(0, 0, 0, 0.2); }
        #idea-box-container h3 { color: #e0f2fe; text-align: center; margin-bottom: 1rem; font-weight: 700; text-shadow: 1px 1px 2px rgba(0,0,0,0.3); }
        #add-idea-form { display: flex; gap: 0.75rem; margin-bottom: 1.25rem; }
        #idea-task-input { flex-grow: 1; border: 1px solid #475569; border-radius: 0.5rem; padding: 0.6rem 0.9rem; box-shadow: inset 0 1px 3px 0 rgba(0,0,0,0.1); font-size: 0.9rem; background-color: #1e293b; color: #f1f5f9; }
        #add-idea-task-btn { background-color: var(--button-secondary-bg); color: white; font-weight: 600; padding: 0.6rem 1.2rem; border-radius: 0.5rem; transition: all 0.2s ease-in-out; box-shadow: 0 2px 5px rgba(0,0,0,0.15); border: none; cursor: pointer; white-space: nowrap; }
        #add-idea-task-btn:hover { background-color: var(--button-secondary-hover); transform: translateY(-1px) scale(1.02); box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
        #idea-task-list { max-height: 250px; overflow-y: auto; padding-right: 5px; }
        .idea-task { background-color: var(--idea-task-bg); color: var(--idea-task-text); border-radius: 0.375rem; padding: 0.6rem 0.9rem; margin-bottom: 0.75rem; cursor: grab; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08); transition: all 0.2s ease-in-out; word-break: break-word; position: relative; display: flex; justify-content: space-between; align-items: center; border-left: 4px solid #60a5fa; }
         .idea-task span { flex-grow: 1; margin-right: 0.5rem; }
        .idea-task:active { cursor: grabbing; }
        .delete-idea-task-btn { background: none; border: none; color: #ef4444; font-size: 1.1rem; line-height: 1; cursor: pointer; padding: 0.1rem 0.2rem; opacity: 0.5; transition: all 0.2s ease; flex-shrink: 0; }
        .idea-task:hover .delete-idea-task-btn { opacity: 1; }
        .delete-idea-task-btn:hover { transform: scale(1.2); color: #b91c1c; }

        /* Daily Summary Styling */
        #daily-summary { background-color: var(--summary-bg); border: 1px solid rgba(255, 255, 255, 0.15); padding: 1.5rem; border-radius: 0.75rem; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); margin-top: 2.5rem; max-width: 6xl; margin-left: auto; margin-right: auto; }
        #daily-summary h3 { color: var(--summary-header); font-weight: 700; margin-bottom: 0.75rem; }
        #daily-summary p { color: var(--summary-text); font-size: 0.95rem; line-height: 1.6; }
        #daily-summary strong { font-weight: 700; color: var(--summary-strong); }
        #daily-summary .motivation-suffix { display: block; margin-top: 1rem; font-style: italic; color: #93c5fd; }

        /* Edit/Delete Styles (for daily tasks) */
        .task-edit-form { display: flex; flex-direction: column; gap: 0.6rem; }
        .task-edit-form input[type="text"], .task-edit-form input[type="time"] { width: 100%; border: 1px solid #94a3b8; border-radius: 0.375rem; padding: 0.4rem 0.6rem; font-size: 0.875rem; background-color: #f8fafc; color: #1e293b; }
        .task-edit-form .edit-time-inputs { display: flex; gap: 0.6rem; }
        .task-edit-form .edit-time-inputs > div { flex-grow: 1; }
        .task-edit-form .edit-buttons { display: flex; justify-content: flex-end; gap: 0.6rem; margin-top: 0.6rem; }
        .task-edit-form button { padding: 0.3rem 0.7rem; border-radius: 0.375rem; font-size: 0.8rem; font-weight: 700; transition: all 0.2s ease; border: none; cursor: pointer; text-transform: uppercase; }
        .edit-save-btn { background-color: var(--button-secondary-bg); color: white; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .edit-save-btn:hover { background-color: var(--button-secondary-hover); transform: scale(1.05); box-shadow: 0 3px 6px rgba(0,0,0,0.15); }
        .edit-cancel-btn { background-color: var(--button-cancel-bg); color: #1e293b; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .edit-cancel-btn:hover { background-color: var(--button-cancel-hover); transform: scale(1.05); box-shadow: 0 3px 6px rgba(0,0,0,0.15); }
        .delete-task-btn { position: absolute; top: 0.4rem; right: 0.4rem; background: none; border: none; color: #fca5a5; font-size: 1.2rem; line-height: 1; cursor: pointer; padding: 0.1rem; opacity: 0.4; transition: all 0.2s ease; }
        .kanban-task:hover .delete-task-btn { opacity: 0.8; }
        .delete-task-btn:hover { opacity: 1; color: #ef4444; transform: scale(1.15) rotate(10deg); }
        .kanban-task.editing { cursor: default; border-left-color: var(--button-primary-bg); }

        /* Highlight effect for auto-moved tasks */
        .task-just-moved { background-color: rgba(250, 204, 21, 0.3); animation: highlight-fade 1.8s ease-out; }
        @keyframes highlight-fade { 0% { background-color: rgba(250, 204, 21, 0.6); } 100% { background-color: var(--task-bg); } }

        /* Time Prompt Modal Styling */
        #time-prompt-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); backdrop-filter: blur(5px); display: none; align-items: center; justify-content: center; z-index: 10000; }
        #time-prompt-modal.active { display: flex; }
        .modal-content { background-color: var(--modal-content-bg); padding: 2rem; border-radius: 0.75rem; box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4); width: 90%; max-width: 400px; border: 1px solid rgba(255, 255, 255, 0.2); }
        .modal-content h3 { color: #e0f2fe; text-align: center; margin-bottom: 1.5rem; font-size: 1.25rem; }
        .modal-content label { display: block; font-size: 0.9rem; font-weight: 600; color: #cbd5e1; margin-bottom: 0.4rem; margin-top: 1rem; }
        .modal-content input[type="time"] { width: 100%; border: 1px solid #475569; border-radius: 0.5rem; padding: 0.6rem 0.9rem; box-shadow: inset 0 1px 3px 0 rgba(0,0,0,0.1); font-size: 0.9rem; background-color: #334155; color: #f1f5f9; }
        .modal-buttons { display: flex; justify-content: flex-end; gap: 0.75rem; margin-top: 2rem; }
        .modal-buttons button { padding: 0.5rem 1.2rem; border-radius: 0.5rem; font-weight: 700; transition: all 0.2s ease; border: none; cursor: pointer; text-transform: uppercase; font-size: 0.9rem; }
        #modal-save-btn { background-color: var(--button-secondary-bg); color: white; }
        #modal-save-btn:hover { background-color: var(--button-secondary-hover); transform: scale(1.03); }
        #modal-cancel-btn { background-color: var(--button-cancel-bg); color: white; }
        #modal-cancel-btn:hover { background-color: var(--button-cancel-hover); transform: scale(1.03); }
        
        /* Authentication Overlay Styling - Improved */
        #auth-overlay { 
            position: fixed; 
            inset: 0; 
            background-color: rgba(0,0,0,0.7); 
            backdrop-filter: blur(8px);
            display: none; 
            align-items: center; 
            justify-content: center; 
            z-index: 10000;
        }
        #auth-overlay.active { display: flex; }
        #auth-overlay .auth-form { 
            background-color: rgba(30, 41, 59, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 2rem; 
            border-radius: 0.75rem; 
            width: 90%; 
            max-width: 340px; 
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
            color: #f1f5f9;
        }
        #auth-overlay h2 {
            font-size: 1.5rem;
            margin-bottom: 1.5rem;
            text-align: center;
            color: white;
        }
        #auth-overlay input:not([type="checkbox"]) { 
            width: 100%; 
            margin-top: 0.75rem; 
            padding: 0.75rem 1rem;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 0.5rem; 
            background-color: rgba(15, 23, 42, 0.8);
            color: white;
            margin-bottom: 1rem;
        }
        #auth-overlay input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }
        #auth-overlay label { 
            color: #e2e8f0; 
            font-weight: 500; 
            margin-top: 0.75rem;
            margin-bottom: 1.5rem;
            display: flex; 
            align-items: center; 
        }
        #auth-overlay label input[type="checkbox"] {
            margin-right: 0.5rem;
            width: 1rem;
            height: 1rem;
        }
        #auth-overlay button { 
            margin-top: 0.75rem; 
            background-color: var(--button-primary-bg); 
            color: white; 
            padding: 0.75rem 1rem; 
            border: none; 
            border-radius: 0.5rem; 
            width: 100%;
            font-weight: 600;
            transition: all 0.2s ease-in-out;
        }
        #auth-overlay button:hover {
            background-color: var(--button-primary-hover);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }
        #auth-overlay a { 
            color: #93c5fd; 
            text-decoration: underline; 
            font-size: 0.875rem;
            transition: color 0.2s;
        }
        #auth-overlay a:hover {
            color: #bfdbfe;
        }
        #auth-overlay .text-center {
            text-align: center;
            margin-top: 1rem;
        }
        #auth-error-message {
            color: #f87171;
            font-size: 0.875rem;
            margin-top: 0.5rem;
            margin-bottom: 0.5rem;
            text-align: center;
        }

        /* Header with logout button */
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            margin-bottom: 1rem;
        }
        #user-info {
            color: #e2e8f0;
            font-size: 0.875rem;
            font-weight: 500;
        }
        #logout-button {
            background-color: transparent;
            color: #e2e8f0;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 0.375rem 0.75rem;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            transition: all 0.2s;
            cursor: pointer;
        }
        #logout-button:hover {
            background-color: rgba(255, 255, 255, 0.1);
            transform: translateY(-1px);
        }
        
        /* Toast notification */
        #toast-notification { 
            position: fixed; 
            bottom: 20px; 
            left: 50%; 
            transform: translateX(-50%) translateY(100px); 
            background-color: #1e293b; 
            color: white; 
            padding: 0.75rem 1.5rem; 
            border-radius: 0.5rem; 
            z-index: 10001; 
            opacity: 0; 
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out; 
            pointer-events: none;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        #toast-notification.show { 
            opacity: 1; 
            transform: translateX(-50%) translateY(0); 
        }
    </style>
</head>
<body>
    <!-- Authentication Overlay -->
    <div id="auth-overlay" class="auth-overlay active">
        <div class="auth-form" id="login-form">
            <h2>Welcome Back</h2>
            <div id="auth-error-message"></div>
            <input type="email" id="login-email" placeholder="Email address" required>
            <input type="password" id="auth-password" placeholder="Password" required>
            <label><input type="checkbox" id="remember-for-day" class="mr-2">Remember for the day</label>
            <button id="login-button">Login</button>
            <p class="text-center mt-2"><a href="#" id="show-signup">Create new account</a></p>
        </div>
        <div class="auth-form" id="signup-form" style="display:none;">
            <h2>Create Account</h2>
            <div id="signup-error-message"></div>
            <input type="text" id="signup-nickname" placeholder="Your name" required>
            <input type="email" id="signup-email" placeholder="Email address" required>
            <input type="password" id="signup-password" placeholder="Password" required>
            <button id="signup-button">Sign Up</button>
            <p class="text-center mt-2"><a href="#" id="show-login">Back to login</a></p>
        </div>
    </div>

    <div id="main-content-wrapper" class="hidden">
        <header>
            <h1 id="main-title" class="text-4xl font-extrabold text-center">SNG's Hustle Board</h1>
            <div id="user-controls">
                <span id="user-info"></span>
                <button id="logout-button">Logout</button>
            </div>
        </header>
        <p id="subtitle" class="text-center text-lg mb-6">Plan & Conquer.</p>

        <div id="time-date-display" class="text-base">Loading time...</div>
        <div id="motivational-quote">Loading inspiration...</div>
        <div id="date-selector-container">
            <label for="date-selector">Select Date:</label>
            <input type="date" id="date-selector">
        </div>
        <div id="selected-date-display" class="text-lg">Loading tasks for...</div>

        <div class="mb-10 max-w-xl mx-auto" id="add-task-form-container">
            <h2 class="text-2xl font-bold mb-5 text-center text-slate-100">Add New Hustle (Today)</h2>
            <div id="add-task-form">
                <div>
                    <label for="new-task-input">Task:</label>
                    <input type="text" id="new-task-input" placeholder="Define the next victory..." class="focus:outline-none focus:ring-2 focus:ring-red-500 focus:border-transparent">
                </div>
                <div>
                    <label for="new-task-start-time">Start (Optional):</label>
                    <input type="time" id="new-task-start-time" class="focus:outline-none focus:ring-2 focus:ring-red-500 focus:border-transparent">
                </div>
                <div>
                    <label for="new-task-end-time">End (Optional):</label>
                    <input type="time" id="new-task-end-time" class="focus:outline-none focus:ring-2 focus:ring-red-500 focus:border-transparent">
                </div>
                <div>
                    <button id="add-task-btn" class="w-full">Lock It In</button>
                </div>
            </div>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-8 max-w-6xl mx-auto">
            <div id="todo" class="kanban-column" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event)">
                <h2 class="text-xl mb-5">🎯 To Do</h2>
                <div class="tasks-container">
                </div>
            </div>
            <div id="inprogress" class="kanban-column" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event)">
                <h2 class="text-xl mb-5">🔥 In Progress</h2>
                 <div class="tasks-container">
                </div>
            </div>
            <div id="done" class="kanban-column" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event)">
                <h2 class="text-xl mb-5">🏆 Done!</h2>
                 <div class="tasks-container">
                </div>
            </div>
        </div>

        <div id="idea-box-container">
            <h3 class="text-xl font-bold">💡 Idea Box (Unscheduled Tasks)</h3>
            <div id="add-idea-form">
                <input type="text" id="idea-task-input" placeholder="Capture a new idea..." class="focus:outline-none focus:ring-2 focus:ring-blue-400 focus:border-transparent">
                <button id="add-idea-task-btn">Add Idea</button>
            </div>
            <div id="idea-task-list">
                <p class="text-slate-400 text-center italic">Loading ideas...</p>
            </div>
        </div>

        <div id="daily-summary" class="hidden"> <h3 class="text-xl font-bold">Daily Wins Recap!</h3>
            <p id="summary-content">No summary available yet.</p>
        </div>

    </div> <canvas id="confetti-canvas"></canvas>

    <div id="time-prompt-modal">
        <div class="modal-content">
            <h3>Schedule Idea Task</h3>
            <p id="modal-task-text" class="text-slate-300 mb-4 text-center"></p> <div>
                <label for="modal-start-time">Start Time:</label>
                <input type="time" id="modal-start-time">
            </div>
            <div>
                <label for="modal-end-time">End Time:</label>
                <input type="time" id="modal-end-time">
            </div>
            <div class="modal-buttons">
                <button id="modal-cancel-btn">Cancel</button>
                <button id="modal-save-btn">Save to Schedule</button>
            </div>
        </div>
    </div>
    
    <div id="toast-notification"></div>
    <script>
        // --- Firebase Configuration ---
        // Replace this with your actual Firebase config
        const firebaseConfig = {
          apiKey: "AIzaSyBygcOaz8etf0XycZ4ILTrUkSXD-SKhFVM", 
          authDomain: "sng-hustle-board-standalone.firebaseapp.com",
          projectId: "sng-hustle-board-standalone",
          storageBucket: "sng-hustle-board-standalone.appspot.com",
          messagingSenderId: "892064086812",
          appId: "1:892064086812:web:4f0aeec9a6bd24c92958d9"
        };
        // --- End Firebase Configuration ---

        // --- Initialize Firebase ---
        let db;
        let auth;
        let currentUser = null;
        let currentUserId = null;
        
        try {
            // Initialize Firebase App if it hasn't been initialized yet
            if (!firebase.apps.length) {
                 firebase.initializeApp(firebaseConfig);
            } else {
                 firebase.app(); // if already initialized, use that app
            }
            // Get Firestore instance
            db = firebase.firestore();
            auth = firebase.auth();
            console.log("Firebase initialized successfully.");
        } catch (error) {
            console.error("Firebase initialization failed:", error);
            showToast("Running in offline mode. Your data will be stored locally.");
            db = null;
            auth = null;
        }

        // --- Auth Elements ---
        const authOverlay = document.getElementById("auth-overlay");
        const loginForm = document.getElementById("login-form");
        const signupForm = document.getElementById("signup-form");
        const showSignupLink = document.getElementById("show-signup");
        const showLoginLink = document.getElementById("show-login");
        const loginButton = document.getElementById("login-button");
        const signupButton = document.getElementById("signup-button");
        const rememberCheckbox = document.getElementById("remember-for-day");
        const loginEmail = document.getElementById("login-email");
        const authPassword = document.getElementById("auth-password");
        const signupNickname = document.getElementById("signup-nickname");
        const signupEmail = document.getElementById("signup-email");
        const signupPassword = document.getElementById("signup-password");
        const authErrorMessage = document.getElementById("auth-error-message");
        const signupErrorMessage = document.getElementById("signup-error-message");
        const logoutButton = document.getElementById("logout-button");
        const userInfo = document.getElementById("user-info");
        const mainContentWrapper = document.getElementById("main-content-wrapper");

        // --- Firestore Collection References ---
        // Assigned after authentication
        let hustleTasksCollection;
        let hustleArchiveCollection;
        let hustleIdeaBoxCollection;
        // Legacy root collections for migration
        const legacyTasksCollection = db ? db.collection("hustle_tasks") : null;
        const legacyIdeaBoxCollection = db ? db.collection("hustle_ideaBoxTasks") : null;
        const legacyArchiveCollection = db ? db.collection("hustle_archive") : null;

        // --- Constants ---
        const BOSTON_TIMEZONE = 'America/New_York'; // Timezone for date/time operations
        const TASK_CHECK_INTERVAL = 60000; // Check tasks every 60 seconds (1 minute)
        const TIMER_UPDATE_INTERVAL = 15000; // Update in-progress timers every 15 seconds
        const LAST_MINUTE_INTERVAL = 1000; // Update timers every second when less than a minute remains

        // --- Motivational Quotes & Suffixes ---
        const motivationalQuotes = [
            "The mind is everything. What you think you become. - Buddha",
            "Whether you think you can, or you think you can't – you're right. - Henry Ford",
            "The only limit to our realization of tomorrow will be our doubts of today. - Franklin D. Roosevelt",
            "Your time is limited, so don't waste it living someone else's life. - Steve Jobs",
            "The trouble is, you think you have time. - Buddha",
            "Lost time is never found again. - Benjamin Franklin",
            "Time is what we want most, but what we use worst. - William Penn",
            "The purpose of life, after all, is to live it, to taste experience to the utmost, to reach out eagerly and without fear for newer and richer experience. - Eleanor Roosevelt",
            "Life is not a problem to be solved, but a reality to be experienced. - Soren Kierkegaard",
            "In the end, it's not the years in your life that count. It's the life in your years. - Abraham Lincoln",
            "Get busy living or get busy dying. - Stephen King (from The Shawshank Redemption)",
            "Very little is needed to make a happy life; it is all within yourself, in your way of thinking. - Marcus Aurelius",
            "You have power over your mind – not outside events. Realize this, and you will find strength. - Marcus Aurelius",
            "The two most important days in your life are the day you are born and the day you find out why. - Mark Twain",
            "Don't be pushed around by the fears in your mind. Be led by the dreams in your heart. - Roy T. Bennett"
        ];
        let currentQuoteIndex = -1; // To track the last shown quote index
        const motivationalSuffixes = [
            "Each step forward, no matter how small, builds momentum towards the happy, healthy, and abundant life you're creating. Keep going!", "Remember why you started! Every completed task is a brick laid on the foundation of your dream life – full of joy, well-being, and success.", "You're not just checking boxes; you're actively crafting a future filled with health, wealth, and happiness. Celebrate the progress!", "This hustle is fueling your journey towards enjoying every moment, backed by fitness and financial freedom. Awesome work!", "Stay focused on the vision: a vibrant life filled with health, prosperity, and genuine enjoyment. Today's wins are paving the way!"
        ];
        let currentSuffixIndex = -1; // To track the last shown summary suffix

        // --- DOM Elements ---
        // Get references to frequently used DOM elements
        const columns = document.querySelectorAll('.kanban-column');
        const timeDateDisplay = document.getElementById('time-date-display');
        const dateSelector = document.getElementById('date-selector');
        const selectedDateDisplay = document.getElementById('selected-date-display');
        const dailySummaryDiv = document.getElementById('daily-summary');
        const summaryContentP = document.getElementById('summary-content');
        const confettiCanvas = document.getElementById('confetti-canvas');
        const quoteDisplay = document.getElementById('motivational-quote');
        const ideaTaskInput = document.getElementById('idea-task-input');
        const addIdeaTaskBtn = document.getElementById('add-idea-task-btn');
        const ideaTaskList = document.getElementById('idea-task-list');
        const timePromptModal = document.getElementById('time-prompt-modal');
        const modalTaskText = document.getElementById('modal-task-text');
        const modalStartTimeInput = document.getElementById('modal-start-time');
        const modalEndTimeInput = document.getElementById('modal-end-time');
        const modalSaveBtn = document.getElementById('modal-save-btn');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');
        const toastElement = document.getElementById('toast-notification');

        // --- Helper Functions ---
        // Helper function to log Firebase status
        function logFirebaseStatus() {
            console.log("----- FIREBASE STATUS -----");
            console.log("Firebase db object exists:", !!db);
            console.log("Firebase auth object exists:", !!auth);
            console.log("Current user:", auth?.currentUser ? auth.currentUser.email : "None");
            console.log("User UID variable:", currentUserId);
            console.log("hustleTasksCollection exists:", !!hustleTasksCollection);
            console.log("hustleIdeaBoxCollection exists:", !!hustleIdeaBoxCollection);
            console.log("hustleArchiveCollection exists:", !!hustleArchiveCollection);
            console.log("--------------------------");
        }

        // --- Authentication Functions ---
        function validateEmail(email) {
            const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            return re.test(String(email).toLowerCase());
        }

        async function loginWithEmailPassword(email, password, remember = false) {
            if (!auth) {
                // Handle offline mode login
                const offlineUserId = `offline-${email}`;
                setCurrentUser({
                    uid: offlineUserId,
                    email: email,
                    displayName: email.split('@')[0]
                });
                showToast("Logged in offline mode. Your data will be stored locally.");
                setupCollections(offlineUserId);
                hideAuthOverlay();
                
                if (remember) {
                    storeRememberForDay(offlineUserId, email, password);
                }
                return;
            }
            
            try {
                authErrorMessage.textContent = "";
                const userCredential = await auth.signInWithEmailAndPassword(email, password);
                console.log("Login successful");
                
                // Handle remember for the day
                if (remember) {
                    storeRememberForDay(userCredential.user.uid, email, password);
                } else {
                    clearRememberForDay();
                }
                
                setCurrentUser(userCredential.user);
                setupCollections(userCredential.user.uid);
                hideAuthOverlay();
                showToast(`Welcome back, ${userCredential.user.displayName || email.split('@')[0]}!`);
                
            } catch (error) {
                console.error("Login error:", error);
                authErrorMessage.textContent = error.message;
                
                // Handle common errors with more user-friendly messages
                if (error.code === 'auth/user-not-found') {
                    authErrorMessage.textContent = "No account found with this email.";
                } else if (error.code === 'auth/wrong-password') {
                    authErrorMessage.textContent = "Incorrect password.";
                } else if (error.code === 'auth/invalid-email') {
                    authErrorMessage.textContent = "Please enter a valid email address.";
                } else if (error.code === 'auth/too-many-requests') {
                    authErrorMessage.textContent = "Too many failed login attempts. Try again later.";
                }
            }
        }

        async function createAccount(nickname, email, password) {
            if (!auth) {
                // Handle offline account creation
                const offlineUserId = `offline-${email}`;
                setCurrentUser({
                    uid: offlineUserId,
                    email: email,
                    displayName: nickname
                });
                showToast("Account created in offline mode. Your data will be stored locally.");
                setupCollections(offlineUserId);
                hideAuthOverlay();
                return;
            }
            
            try {
                signupErrorMessage.textContent = "";
                
                if (nickname.trim() === '') {
                    signupErrorMessage.textContent = "Please enter your name.";
                    return;
                }
                
                if (!validateEmail(email)) {
                    signupErrorMessage.textContent = "Please enter a valid email address.";
                    return;
                }
                
                if (password.length < 6) {
                    signupErrorMessage.textContent = "Password must be at least 6 characters.";
                    return;
                }
                
                // Create user in Firebase
                const userCredential = await auth.createUserWithEmailAndPassword(email, password);
                
                // Update profile with nickname
                await userCredential.user.updateProfile({
                    displayName: nickname
                });
                
                // Store additional user info in Firestore
                await db.collection('users').doc(userCredential.user.uid).set({
                    nickname: nickname,
                    email: email,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                console.log("Account created successfully");
                
                setCurrentUser(userCredential.user);
                setupCollections(userCredential.user.uid);
                hideAuthOverlay();
                showToast(`Welcome, ${nickname}! Your account has been created.`);
                
            } catch (error) {
                console.error("Signup error:", error);
                signupErrorMessage.textContent = error.message;
                
                // Handle common errors with more user-friendly messages
                if (error.code === 'auth/email-already-in-use') {
                    signupErrorMessage.textContent = "This email is already registered. Try logging in instead.";
                } else if (error.code === 'auth/invalid-email') {
                    signupErrorMessage.textContent = "Please enter a valid email address.";
                } else if (error.code === 'auth/weak-password') {
                    signupErrorMessage.textContent = "Password is too weak. Use at least 6 characters.";
                }
            }
        }

        function setCurrentUser(user) {
            currentUser = user;
            currentUserId = user.uid;
            
            if (userInfo) {
                userInfo.textContent = user.displayName || user.email.split('@')[0];
            }
        }

        function logout() {
            if (auth && auth.currentUser) {
                auth.signOut()
                    .then(() => {
                        console.log("Logged out successfully");
                    })
                    .catch(error => {
                        console.error("Logout error:", error);
                    });
            }
            
            // Clear user data regardless of auth status
            currentUser = null;
            currentUserId = null;
            hustleTasksCollection = null;
            hustleIdeaBoxCollection = null;
            hustleArchiveCollection = null;
            
            // Clear local remember data
            clearRememberForDay();
            
            // Reset UI
            showAuthOverlay();
            clearBoard();
            
            showToast("Logged out successfully.");
        }

        function showAuthOverlay() {
            if (authOverlay) {
                mainContentWrapper.classList.add('hidden');
                authOverlay.classList.add('active');
                authErrorMessage.textContent = "";
                signupErrorMessage.textContent = "";
                
                // Clear password fields
                authPassword.value = "";
                signupPassword.value = "";
            }
        }

        function hideAuthOverlay() {
            if (authOverlay) {
                authOverlay.classList.remove('active');
                mainContentWrapper.classList.remove('hidden');
            }
        }

        function setupCollections(userId) {
            if (db) {
                console.log("Setting up collections for user:", userId);
                hustleTasksCollection = db.collection(`users/${userId}/hustle_tasks`);
                hustleIdeaBoxCollection = db.collection(`users/${userId}/hustle_ideaBoxTasks`);
                hustleArchiveCollection = db.collection(`users/${userId}/hustle_archive`);
            } else {
                console.warn("Database not initialized, using local storage only");
            }
            
            // Initialize the app with the current date
            initializeApp();
        }

        // Store login info for a day
        function storeRememberForDay(uid, email, password) {
            try {
                const expiryDate = new Date();
                expiryDate.setHours(23, 59, 59, 999); // Set to end of day
                
                const loginData = {
                    uid: uid,
                    email: email,
                    password: password,
                    expiry: expiryDate.getTime()
                };
                
                localStorage.setItem('hustleBoard_remember', JSON.stringify(loginData));
                console.log("Login info stored for the day");
                
                // Set timeout to clear data at expiry
                const timeUntilExpiry = expiryDate.getTime() - Date.now();
                if (timeUntilExpiry > 0) {
                    setTimeout(() => {
                        clearRememberForDay();
                    }, timeUntilExpiry);
                }
                
            } catch (error) {
                console.error("Error storing login info:", error);
                // Continue without storing (non-critical error)
            }
        }

        function clearRememberForDay() {
            localStorage.removeItem('hustleBoard_remember');
            console.log("Login info cleared");
        }

        function checkRememberedLogin() {
            try {
                const rememberedLogin = localStorage.getItem('hustleBoard_remember');
                
                if (!rememberedLogin) {
                    return false;
                }
                
                const loginData = JSON.parse(rememberedLogin);
                
                // Check if login data is expired
                if (loginData.expiry < Date.now()) {
                    clearRememberForDay(); // Clear expired data
                    return false;
                }
                
                console.log("Found remembered login, attempting auto-login");
                
                // Auto-login with stored credentials
                loginWithEmailPassword(loginData.email, loginData.password, true);
                return true;
                
            } catch (error) {
                console.error("Error checking remembered login:", error);
                clearRememberForDay(); // Clear potentially corrupted data
                return false;
            }
        }

        // --- Setup Auth Listeners ---
        if (showSignupLink) {
            showSignupLink.addEventListener('click', (e) => {
                e.preventDefault();
                loginForm.style.display = 'none';
                signupForm.style.display = 'block';
            });
        }

        if (showLoginLink) {
            showLoginLink.addEventListener('click', (e) => {
                e.preventDefault();
                signupForm.style.display = 'none';
                loginForm.style.display = 'block';
            });
        }

        if (loginButton) {
            loginButton.addEventListener('click', (e) => {
                e.preventDefault();
                const email = loginEmail.value.trim();
                const password = authPassword.value;
                const remember = rememberCheckbox.checked;
                
                if (email && password) {
                    loginWithEmailPassword(email, password, remember);
                } else {
                    authErrorMessage.textContent = "Please enter your email and password.";
                }
            });
        }

        if (signupButton) {
            signupButton.addEventListener('click', (e) => {
                e.preventDefault();
                const nickname = signupNickname.value.trim();
                const email = signupEmail.value.trim();
                const password = signupPassword.value;
                
                if (nickname && email && password) {
                    createAccount(nickname, email, password);
                } else {
                    signupErrorMessage.textContent = "Please fill in all fields.";
                }
            });
        }

        if (logoutButton) {
            logoutButton.addEventListener('click', () => {
                logout();
            });
        }

        // Listen for auth state changes
        if (auth) {
            auth.onAuthStateChanged(user => {
                if (user) {
                    console.log("Auth state changed: User is signed in", user.uid);
                    setCurrentUser(user);
                    setupCollections(user.uid);
                    hideAuthOverlay();
                } else {
                    console.log("Auth state changed: User is signed out");
                    // Check for remembered login before showing auth overlay
                    if (!checkRememberedLogin()) {
                        currentUser = null;
                        currentUserId = null;
                        showAuthOverlay();
                    }
                }
            });
        }

        // --- Confetti Setup ---
        let myConfetti = null;
        // Initialize confetti only if the library is loaded
        if (typeof confetti !== 'undefined') {
             myConfetti = confetti.create(confettiCanvas, { resize: true, useWorker: true });
        } else {
             console.warn("Confetti library not loaded.");
        }

        // --- State Variables ---
        let draggedElement = null;      // Stores the element being dragged
        let draggedElementType = null;  // Stores the type ('kanban-task' or 'idea-task') of the dragged element
        let currentSelectedDate = '';   // Stores the currently selected date string (YYYY-MM-DD)
        let taskCheckIntervalId = null; // Stores the interval ID for checking task start times
        let progressTimerIntervalId = null; // Stores the interval ID for updating progress bars
        let lastMinuteIntervalId = null; // Stores the interval ID for faster updates in the last minute
        let ideaTaskToSchedule = null;  // Stores idea task data when prompting for time
        let transactionsData = [];

        // --- Toast Notification ---
        let toastTimeout;
        function showToast(message, duration = 3000) {
            if (!toastElement) return;
            
            toastElement.textContent = message;
            toastElement.classList.add('show');
            
            if (toastTimeout) {
                clearTimeout(toastTimeout);
            }
            
            toastTimeout = setTimeout(() => {
                toastElement.classList.remove('show');
            }, duration);
        }

        // --- Utility Functions ---

        // Gets the current date in YYYY-MM-DD format for a given timezone
        function getCurrentDateString(timeZone) {
            const now = new Date();
            return now.toISOString().split('T')[0]; // Simple fallback method
        }

        // Gets the current time in HH:MM (24-hour) format for a given timezone
        function getCurrentTimeString(timeZone) {
            const now = new Date();
            return now.toTimeString().substring(0, 5); // Returns HH:MM
        }

        // Formats the current date and time for display (e.g., "Wednesday, April 30, 2025, 4:23 PM EDT")
        function formatLiveDateTime(timeZone) {
            const now = new Date();
            return now.toLocaleString('en-US', { 
                weekday: 'long', 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric',
                hour: 'numeric', 
                minute: '2-digit', 
                hour12: true
            });
        }

        // Formats a YYYY-MM-DD date string into a more readable format (e.g., "April 30, 2025")
        function formatDisplayDate(dateString) {
            if (!dateString || !/^\d{4}-\d{2}-\d{2}$/.test(dateString)) return "Invalid Date";
            const [year, month, day] = dateString.split('-');
            const date = new Date(Number(year), Number(month) - 1, Number(day));
            return date.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
        }

        // Calculates the duration between two HH:MM time strings (e.g., "1h 30m")
        function calculateDuration(startTime, endTime) {
            if (!startTime || !endTime) return "";
            try {
                // Create date objects on a common date to compare times
                const start = new Date(`1970-01-01T${startTime}:00`);
                const end = new Date(`1970-01-01T${endTime}:00`);
                if (isNaN(start) || isNaN(end) || end <= start) return ""; // Invalid or end time is not after start time

                let diffMillis = end - start;
                const hours = Math.floor(diffMillis / (1000 * 60 * 60));
                diffMillis -= hours * (1000 * 60 * 60);
                const minutes = Math.floor(diffMillis / (1000 * 60));

                let durationStr = "";
                if (hours > 0) durationStr += `${hours}h `;
                if (minutes > 0) durationStr += `${minutes}m`;
                return durationStr.trim();
            } catch (e) {
                console.error("Error calculating duration:", e);
                return ""; // Return empty string on error
            }
        }

        // Formats an HH:MM time string into 12-hour format with AM/PM
        function formatTimeTo12Hour(timeString) {
            if (!timeString || !/^\d{2}:\d{2}$/.test(timeString)) {
                return timeString; // Return original if format is invalid
            }
            const [hours, minutes] = timeString.split(':');
            const hourNum = parseInt(hours, 10);
            const ampm = hourNum >= 12 ? 'PM' : 'AM';
            let hour12 = hourNum % 12;
            if (hour12 === 0) { // Handle midnight (00:xx) and noon (12:xx)
                hour12 = 12;
            }
            return `${hour12}:${minutes} ${ampm}`;
        }


        // --- Data Management Functions (Firestore & Local Storage) ---

        // Save tasks for a date to localStorage
        function saveTasksToLocalStorage(dateString, tasksForDate) {
            try {
                localStorage.setItem(`${currentUserId}_tasks-${dateString}`, JSON.stringify(tasksForDate));
                console.log(`Saved tasks to localStorage for user ${currentUserId}, date: ${dateString}`);
            } catch (e) {
                console.error('Failed to save tasks to localStorage:', e);
            }
        }

        // Load tasks for a date from localStorage
        function loadTasksFromLocalStorage(dateString) {
            try {
                const data = localStorage.getItem(`${currentUserId}_tasks-${dateString}`);
                if (data) {
                    const parsed = JSON.parse(data);
                    console.log(`Loaded tasks from localStorage for user ${currentUserId}, date: ${dateString}`);
                    return {
                        todo: Array.isArray(parsed.todo) ? parsed.todo : [],
                        inprogress: Array.isArray(parsed.inprogress) ? parsed.inprogress : [],
                        done: Array.isArray(parsed.done) ? parsed.done : []
                    };
                }
            } catch (e) {
                console.error('Failed to load tasks from localStorage:', e);
            }
            return { todo: [], inprogress: [], done: [] };
        }

        // Improved loadTasksFromFirestore function
        async function loadTasksFromFirestore(dateString) {
            // Check if Firestore is initialized
            if (!db || !hustleTasksCollection) {
                console.log("Using localStorage as Firestore is not available");
                return loadTasksFromLocalStorage(dateString);
            }

            console.log(`Attempting to load daily tasks for date: ${dateString}...`);
            // Validate the date string format
            if (!dateString || typeof dateString !== 'string' || !/^\d{4}-\d{2}-\d{2}$/.test(dateString)) {
                console.error(`Invalid dateString provided to loadTasksFromFirestore: ${dateString}`);
                showToast(`Internal Error: Invalid date format. Using local data if available.`);
                return loadTasksFromLocalStorage(dateString);
            }
            
            // Get a reference to the specific date document
            const docRef = hustleTasksCollection.doc(dateString);
            const legacyDocRef = legacyTasksCollection ? legacyTasksCollection.doc(dateString) : null;

            try {
                console.log(`Fetching document: ${docRef.path}`);
                const docSnap = await docRef.get(); // Attempt to get the document

                if (docSnap.exists) { // Check the boolean property for Compat SDK
                    console.log(`Document found for ${dateString}. Data:`, docSnap.data());
                    const data = docSnap.data() || {}; // Use empty object if data is null/undefined

                    // Validate the structure of the data, providing defaults if fields are missing/invalid
                    const tasks = {
                        todo: Array.isArray(data.todo) ? data.todo : [],
                        inprogress: Array.isArray(data.inprogress) ? data.inprogress : [],
                        done: Array.isArray(data.done) ? data.done : []
                    };
                    
                    // Save to localStorage as backup but don't return localStorage data
                    saveTasksToLocalStorage(dateString, tasks);
                    return tasks;
                } else if (legacyDocRef) {
                    const legacySnap = await legacyDocRef.get();
                    if (legacySnap.exists) {
                        const legacyData = legacySnap.data() || {};
                        await docRef.set(legacyData);
                        console.log(`Migrated legacy data for ${dateString} to user collection.`);
                        const migrated = {
                            todo: Array.isArray(legacyData.todo) ? legacyData.todo : [],
                            inprogress: Array.isArray(legacyData.inprogress) ? legacyData.inprogress : [],
                            done: Array.isArray(legacyData.done) ? legacyData.done : []
                        };
                        saveTasksToLocalStorage(dateString, migrated);
                        return migrated;
                    } else {
                        console.log(`No document found for ${dateString}, returning empty task lists.`);
                        return { todo: [], inprogress: [], done: [] };
                    }
                } else {
                    console.log(`No document found for ${dateString}, returning empty task lists.`);
                    return { todo: [], inprogress: [], done: [] };
                }
            } catch (error) {
                // Log detailed error information if the fetch fails
                console.error(`Error loading daily tasks document for ${dateString}:`, error);
                
                // Show a user-friendly alert
                showToast(`Failed to load tasks for ${formatDisplayDate(dateString)}. Using local data if available.`);

                // Fallback to any tasks stored locally
                return loadTasksFromLocalStorage(dateString);
            }
        }

        // Improved saveTasksToFirestore function
        async function saveTasksToFirestore(dateString, tasksForDate) {
            // Always save to localStorage as a backup
            saveTasksToLocalStorage(dateString, tasksForDate);
            
            // Check if Firestore is initialized
            if (!db || !hustleTasksCollection) {
                console.log("Skipping Firestore save as it's not available");
                return;
            }
            
            // Validate the date string format
            if (!dateString || typeof dateString !== 'string' || !/^\d{4}-\d{2}-\d{2}$/.test(dateString)) {
                console.error(`Invalid dateString provided to saveTasksToFirestore: ${dateString}. Aborting save.`);
                showToast(`Error saving tasks: Invalid date format. Your changes are saved locally.`);
                return;
            }
            
            console.log(`Attempting to save daily tasks for ${dateString}...`);
            
            // Get a reference to the specific date document
            const docRef = hustleTasksCollection.doc(dateString);
            const legacyDocRef = legacyTasksCollection ? legacyTasksCollection.doc(dateString) : null;
            
            try {
                // Use set() to completely overwrite the document with the new state
                await docRef.set(tasksForDate);
                if (legacyDocRef) {
                    try { await legacyDocRef.delete(); } catch(e) { /* ignore */ }
                }
                console.log("Daily tasks successfully saved to Firestore:", dateString);
            } catch (error) {
                // Log detailed error information if saving fails
                console.error(`Error saving daily tasks for ${dateString}:`, error);
                
                // Check for specific permission errors
                if (error.code === 'permission-denied') {
                    showToast(`Permission denied! You don't have permission to save tasks. Try logging in again.`);
                } else {
                    showToast(`Error saving to cloud. Your changes are saved locally.`);
                }
            }
        }

        /**
         * Loads all tasks from the 'hustle_ideaBoxTasks' collection, ordered by creation time.
         * @returns {Promise<Array>} A promise that resolves to an array of idea task objects.
         */
        async function loadIdeaTasksFromFirestore() {
            const storedIdeas = localStorage.getItem(`${currentUserId}_hustle_ideaBoxTasks`);
            let ideaTasks = [];
            
            // Try to load from localStorage first
            if (storedIdeas) {
                try {
                    ideaTasks = JSON.parse(storedIdeas);
                    console.log(`Loaded ${ideaTasks.length} idea tasks from localStorage for user ${currentUserId}`);
                } catch (error) {
                    console.error("Error parsing idea tasks from localStorage:", error);
                }
            }
            
            // If Firestore is not available, return localStorage results
            if (!db || !hustleIdeaBoxCollection) { 
                console.log("Using localStorage for idea tasks as Firestore is not available");
                return ideaTasks; 
            }
            
            console.log("Loading idea tasks from Firestore...");
            
            try {
                // Query the collection, ordering by 'createdAt' descending
                let querySnapshot = await hustleIdeaBoxCollection.orderBy("createdAt", "desc").get();
                if (querySnapshot.empty && legacyIdeaBoxCollection) {
                    const legacySnap = await legacyIdeaBoxCollection.orderBy("createdAt", "desc").get();
                    ideaTasks = [];
                    legacySnap.forEach(async doc => {
                        ideaTasks.push({ id: doc.id, ...doc.data() });
                        await hustleIdeaBoxCollection.doc(doc.id).set(doc.data());
                        await legacyIdeaBoxCollection.doc(doc.id).delete().catch(()=>{});
                    });
                    console.log(`Migrated ${legacySnap.size} legacy idea tasks.`);
                    
                    // Save to localStorage as backup
                    localStorage.setItem(`${currentUserId}_hustle_ideaBoxTasks`, JSON.stringify(ideaTasks));
                    return ideaTasks;
                }
                
                // If Firestore has data, use it
                if (!querySnapshot.empty) {
                    ideaTasks = [];
                    querySnapshot.forEach((doc) => {
                        ideaTasks.push({ id: doc.id, ...doc.data() });
                    });
                    
                    // Save to localStorage as backup
                    localStorage.setItem(`${currentUserId}_hustle_ideaBoxTasks`, JSON.stringify(ideaTasks));
                }
                
                console.log(`Loaded ${ideaTasks.length} idea tasks from Firestore.`);
                return ideaTasks;
            } catch (error) {
                console.error("Error getting idea tasks from Firestore:", error);
                // Return whatever we have from localStorage
                return ideaTasks;
            }
        }

        /**
         * Adds a new task to the 'hustle_ideaBoxTasks' collection.
         * @param {string} taskText - The text content of the idea task.
         * @returns {Promise<string>} A promise that resolves to the new document's ID.
         */
        async function addIdeaTaskToFirestore(taskText) {
            console.log("Inside addIdeaTaskToFirestore, text:", taskText);
            
            // Generate a client-side ID
            const newId = 'local-' + Date.now() + '-' + Math.random().toString(36).substring(2, 9);
            const newTask = {
                id: newId,
                text: taskText,
                createdAt: new Date()
            };
            
            // Always save to localStorage first
            let ideaTasks = [];
            try {
                const storedIdeas = localStorage.getItem(`${currentUserId}_hustle_ideaBoxTasks`);
                ideaTasks = storedIdeas ? JSON.parse(storedIdeas) : [];
            } catch (error) {
                console.error("Error parsing existing idea tasks:", error);
            }
            
            ideaTasks.unshift(newTask); // Add to beginning of array
            localStorage.setItem(`${currentUserId}_hustle_ideaBoxTasks`, JSON.stringify(ideaTasks));
            console.log(`Added idea task to localStorage: ${newId}`);
            
            // If Firestore is not available, return the local ID
            if (!db || !hustleIdeaBoxCollection) { 
                console.log("Skipping Firestore add as it's not available");
                return newId; 
            }
            
            // Try to save to Firestore
            try {
                // Data to add, including a server timestamp for creation time
                const dataToAdd = {
                    text: taskText,
                    createdAt: firebase.firestore.FieldValue.serverTimestamp()
                };
                
                // Add the document to the collection
                const docRef = await hustleIdeaBoxCollection.add(dataToAdd);
                
                // If successful, update the local storage with the new Firestore ID
                const firestoreId = docRef.id;
                ideaTasks[0].id = firestoreId; // Update the ID in the first item (most recent)
                localStorage.setItem(`${currentUserId}_hustle_ideaBoxTasks`, JSON.stringify(ideaTasks));
                
                console.log(`Firestore add successful. Document ID: ${firestoreId}`);
                return firestoreId;
            } catch (error) {
                // Log error but don't fail - we've already saved to localStorage
                console.error("Error saving idea task to Firestore:", error);
                return newId; // Return the local ID we generated
            }
        }

        /**
         * Deletes a task from the 'hustle_ideaBoxTasks' collection.
         * @param {string} taskId - The ID of the document to delete.
         */
        async function deleteIdeaTaskFromFirestore(taskId) {
            console.log("Attempting to delete idea task with ID:", taskId);
            
            // Remove from localStorage first
            try {
                const storedIdeas = localStorage.getItem(`${currentUserId}_hustle_ideaBoxTasks`);
                if (storedIdeas) {
                    let ideaTasks = JSON.parse(storedIdeas);
                    ideaTasks = ideaTasks.filter(task => task.id !== taskId);
                    localStorage.setItem(`${currentUserId}_hustle_ideaBoxTasks`, JSON.stringify(ideaTasks));
                    console.log(`Removed idea task from localStorage: ${taskId}`);
                }
            } catch (error) {
                console.error("Error updating localStorage after deletion:", error);
            }
            
            // If Firestore is not available or ID is local, we're done
            if (!db || !hustleIdeaBoxCollection || taskId.startsWith('local-')) { 
                return; 
            }
            
            // Try to delete from Firestore
            try {
                await hustleIdeaBoxCollection.doc(taskId).delete();
                if (legacyIdeaBoxCollection) {
                    await legacyIdeaBoxCollection.doc(taskId).delete().catch(()=>{});
                }
                console.log(`Deleted idea task from Firestore: ${taskId}`);
            } catch (error) {
                console.error("Error deleting idea task from Firestore:", error);
                showToast("Could not delete idea from cloud, but it's removed locally.");
            }
        }

        // --- Core Application Functions ---

        // Updates the time display element with the current formatted date and time
        function updateTimeDisplay() {
            if (timeDateDisplay) {
                timeDateDisplay.textContent = formatLiveDateTime(BOSTON_TIMEZONE);
            }
        }

        // Clears all task elements from the Kanban board columns
        function clearBoard() {
            columns.forEach(column => {
                const tc = column.querySelector('.tasks-container');
                if (tc) tc.innerHTML = ''; // Remove all child elements
            });
        }

        // Creates the inner HTML content for a task card (text, time, completion date)
        function createTaskDisplayContent(taskData) {
            const displayWrapper = document.createElement('div');
            displayWrapper.classList.add('task-content-display');

            // Add task text
            const textNode = document.createTextNode(taskData.text || 'No description');
            displayWrapper.appendChild(textNode);

            // Add start/end time and duration if available
            if (taskData.startTime && taskData.endTime) {
                const timeInfoSpan = document.createElement('span');
                timeInfoSpan.classList.add('task-time-info');
                const duration = calculateDuration(taskData.startTime, taskData.endTime);
                const formattedStart = formatTimeTo12Hour(taskData.startTime);
                const formattedEnd = formatTimeTo12Hour(taskData.endTime);
                timeInfoSpan.innerHTML = `${formattedStart} - ${formattedEnd}` + (duration ? ` <span class="duration">(${duration})</span>` : '');
                displayWrapper.appendChild(timeInfoSpan);
            }

            // Add completion date if available
            if (taskData.completionDate) {
                const dateSpan = document.createElement('span');
                dateSpan.classList.add('task-completion-date');
                dateSpan.textContent = `Completed: ${formatDisplayDate(taskData.completionDate)}`;
                displayWrapper.appendChild(dateSpan);
            }
            return displayWrapper;
        }

        // Creates a Kanban task element (div) from task data
        function createTaskElement(taskData, columnId) {
            // Generate a unique ID for the element if not provided (e.g., from Firestore)
            const taskId = taskData.firestoreId || `task-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
            const { text, startTime, endTime, completionDate } = taskData;

            // Create the main task div
            const task = document.createElement('div');
            task.classList.add('kanban-task');
            task.setAttribute('draggable', 'true'); // Make it draggable
            task.id = taskId;

            // Store task data in dataset attributes for easy access
            task.dataset.type = 'kanban-task';
            task.dataset.text = text || '';
            if (startTime) task.dataset.startTime = startTime; // Only set if startTime is not null/empty
            if (endTime) task.dataset.endTime = endTime;       // Only set if endTime is not null/empty
            if (completionDate) task.dataset.completionDate = completionDate;

            // Create and append the display content (text, time, etc.)
            const displayContent = createTaskDisplayContent(taskData);
            task.appendChild(displayContent);

            // Add progress bar elements if the task is in the 'inprogress' column and has times
            if (columnId === 'inprogress' && startTime && endTime) {
                task.appendChild(createProgressElements());
            }

            // Create and append the delete button
            const deleteBtn = document.createElement('button');
            deleteBtn.classList.add('delete-task-btn');
            deleteBtn.innerHTML = '&times;'; // Use '×' symbol
            deleteBtn.setAttribute('aria-label', 'Delete task');
            // Add click handler for deletion
            deleteBtn.onclick = async (event) => {
                event.stopPropagation(); // Prevent triggering edit mode on button click
                if (confirm(`Delete task: "${task.dataset.text}"?`)) {
                    task.remove(); // Remove element immediately from UI
                    await saveCurrentBoardState(); // Save the updated board state to Firestore
                }
            };
            task.appendChild(deleteBtn);

            // Add event listeners for drag-and-drop and double-click editing
            task.addEventListener('dragstart', handleDragStart);
            task.addEventListener('dragend', handleDragEnd);
            task.addEventListener('dblclick', (event) => {
                // Don't enter edit mode if the delete button was clicked
                if (event.target === deleteBtn || deleteBtn.contains(event.target)) return;
                enterEditMode(task);
            });

            return task;
        }

        // Creates the HTML elements for the progress bar and remaining time display
        function createProgressElements() {
            const container = document.createElement('div');
            container.classList.add('task-progress-container');

            const progressBar = document.createElement('div');
            progressBar.classList.add('progress-bar');
            const progressBarFill = document.createElement('div');
            progressBarFill.classList.add('progress-bar-fill');
            progressBar.appendChild(progressBarFill);

            const remainingTimeSpan = document.createElement('span');
            remainingTimeSpan.classList.add('remaining-time');
            remainingTimeSpan.textContent = 'Calculating...'; // Initial text

            container.appendChild(progressBar);
            container.appendChild(remainingTimeSpan);
            return container;
        }

        // --- Idea Box Functions ---

        // Creates an Idea Box task element (div) from idea task data
        function createIdeaTaskElement(ideaTaskData) {
            const { id, text } = ideaTaskData; // Destructure ID and text from data

            // Create the main task div
            const task = document.createElement('div');
            task.classList.add('idea-task');
            task.setAttribute('draggable', 'true'); // Make it draggable
            task.id = `idea-${id}`; // Use Firestore/Local ID for the element ID
            task.dataset.id = id; // Store ID in dataset
            task.dataset.text = text;
            task.dataset.type = 'idea-task'; // Mark type for drag/drop logic

            // Add task text
            const textSpan = document.createElement('span');
            textSpan.textContent = text;
            task.appendChild(textSpan);

            // Create and append the delete button
            const deleteBtn = document.createElement('button');
            deleteBtn.classList.add('delete-idea-task-btn');
            deleteBtn.innerHTML = '&times;';
            deleteBtn.setAttribute('aria-label', 'Delete idea task');

            // Add click handler for deletion
            deleteBtn.addEventListener('click', async (event) => {
                event.stopPropagation();
                // Retrieve the ID directly from the element's dataset when clicked
                const taskIdToDelete = task.dataset.id;
                console.log(`DEBUG: Delete button clicked for idea ID: ${taskIdToDelete}, Text: "${task.dataset.text}"`);

                if (confirm(`Are you sure you want to delete idea: "${task.dataset.text}"?`)) {
                    deleteBtn.disabled = true; // Disable button during deletion
                    try {
                        await deleteIdeaTaskFromFirestore(taskIdToDelete); // Call delete
                        task.remove(); // Remove element from UI on success
                    } catch (error) {
                        deleteBtn.disabled = false; // Re-enable button on error
                        console.error("Failed to delete idea task:", error);
                    }
                }
            });
            task.appendChild(deleteBtn);

            // Add drag-and-drop listeners
            task.addEventListener('dragstart', handleDragStart);
            task.addEventListener('dragend', handleDragEnd);
            return task;
        }

        // Loads and displays tasks from the Idea Box collection in the UI
        async function displayIdeaTasks() {
            if (!ideaTaskList) return; // Ensure the list element exists
            ideaTaskList.innerHTML = '<p class="text-slate-400 text-center italic">Loading ideas...</p>'; // Show loading indicator
            try {
                const ideaTasks = await loadIdeaTasksFromFirestore(); // Fetch tasks
                ideaTaskList.innerHTML = ''; // Clear loading/previous list

                if (ideaTasks.length === 0) {
                    // Show message if no ideas exist
                    ideaTaskList.innerHTML = '<p class="text-slate-400 text-center italic">No ideas captured yet. Add some!</p>';
                } else {
                    // Create and append elements for each idea task
                    ideaTasks.forEach(taskData => {
                        const taskElement = createIdeaTaskElement(taskData);
                        ideaTaskList.appendChild(taskElement);
                    });
                }
            } catch (error) {
                 console.error("Error displaying idea tasks:", error);
                 // Show error message in the UI if loading failed
                 if (ideaTaskList.innerHTML.includes('Loading')) { // Avoid duplicate error messages
                     ideaTaskList.innerHTML = '<p class="text-red-400 text-center italic">Error loading ideas. Please check connection/console.</p>';
                 }
            }
        }

        // Handles adding a new task to the Idea Box
        async function addIdeaTask() {
            console.log("addIdeaTask called");
            
            if (!ideaTaskInput || !addIdeaTaskBtn) { 
                console.error("Idea task input or button not found."); 
                return; 
            }
            const taskText = ideaTaskInput.value.trim(); // Get and trim input value
            if (taskText === '') { // Validate input
                showToast('Please enter an idea description.');
                ideaTaskInput.focus();
                return;
            }

            console.log("Disabling button, text:", taskText);
            addIdeaTaskBtn.disabled = true; 
            addIdeaTaskBtn.textContent = 'Adding...'; // Provide user feedback

            try {
                console.log("Calling addIdeaTaskToFirestore...");
                const newId = await addIdeaTaskToFirestore(taskText); // Add to database
                console.log("Back from addIdeaTaskToFirestore. ID:", newId);

                // Create data object including the new ID received
                const newTaskData = { id: newId, text: taskText, createdAt: new Date() };
                const newTaskElement = createIdeaTaskElement(newTaskData); // Create UI element

                // Update UI
                const placeholder = ideaTaskList.querySelector('p'); // Find placeholder text
                if (placeholder) placeholder.remove(); // Remove placeholder if it exists
                ideaTaskList.prepend(newTaskElement); // Add new task to the top of the list
                ideaTaskInput.value = ''; // Clear input field
                console.log("Successfully added idea to UI:", taskText);

            } catch (error) {
                // Error handling
                console.error("Error in addIdeaTask:", error);
                showToast("Failed to add idea. Please try again.");
            } finally {
                // Always re-enable the button and reset its text
                console.log("Executing finally block in addIdeaTask");
                addIdeaTaskBtn.disabled = false;
                addIdeaTaskBtn.textContent = 'Add Idea';
                ideaTaskInput.focus(); // Set focus back to input
            }
        }


        // --- Edit Mode Functions (Daily Tasks) ---

        // Switches a Kanban task element into edit mode
        function enterEditMode(taskElement) {
            if (taskElement.classList.contains('editing')) return; // Already in edit mode

            taskElement.classList.add('editing');
            taskElement.setAttribute('draggable', 'false'); // Disable dragging while editing

            // Hide the normal display content and progress bar
            const displayContent = taskElement.querySelector('.task-content-display');
            if (displayContent) displayContent.style.display = 'none';
            const progressContainer = taskElement.querySelector('.task-progress-container');
            if (progressContainer) progressContainer.style.display = 'none';

            // Create the edit form elements
            const editForm = document.createElement('div');
            editForm.classList.add('task-edit-form');

            const textInput = document.createElement('input');
            textInput.type = 'text';
            textInput.value = taskElement.dataset.text || '';
            textInput.placeholder = 'Task description';

            const timeInputsDiv = document.createElement('div');
            timeInputsDiv.classList.add('edit-time-inputs');
            const startTimeDiv = document.createElement('div');
            const startTimeInput = document.createElement('input');
            startTimeInput.type = 'time';
            startTimeInput.value = taskElement.dataset.startTime || ''; // Pre-fill with existing or empty
            startTimeDiv.appendChild(startTimeInput);
            const endTimeDiv = document.createElement('div');
            const endTimeInput = document.createElement('input');
            endTimeInput.type = 'time';
            endTimeInput.value = taskElement.dataset.endTime || ''; // Pre-fill with existing or empty
            endTimeDiv.appendChild(endTimeInput);
            timeInputsDiv.appendChild(startTimeDiv);
            timeInputsDiv.appendChild(endTimeDiv);

            const buttonsDiv = document.createElement('div');
            buttonsDiv.classList.add('edit-buttons');
            const saveBtn = document.createElement('button');
            saveBtn.textContent = 'Save';
            saveBtn.classList.add('edit-save-btn');
            saveBtn.onclick = () => saveEdit(taskElement, textInput, startTimeInput, endTimeInput); // Pass elements to save function
            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = 'Cancel';
            cancelBtn.classList.add('edit-cancel-btn');
            cancelBtn.onclick = () => cancelEdit(taskElement);
            buttonsDiv.appendChild(saveBtn);
            buttonsDiv.appendChild(cancelBtn);

            // Append form elements to the task element
            editForm.appendChild(textInput);
            editForm.appendChild(timeInputsDiv);
            editForm.appendChild(buttonsDiv);
            taskElement.appendChild(editForm);

            textInput.focus(); // Focus the text input
        }

        // Exits edit mode for a Kanban task element
        function exitEditMode(taskElement) {
            const editForm = taskElement.querySelector('.task-edit-form');
            if (editForm) editForm.remove(); // Remove the edit form

            // Restore visibility of normal display content and progress bar
            const displayContent = taskElement.querySelector('.task-content-display');
            if (displayContent) displayContent.style.display = '';
            const progressContainer = taskElement.querySelector('.task-progress-container');
            if (progressContainer) progressContainer.style.display = 'flex'; // Use flex for progress bar layout

            taskElement.classList.remove('editing');
            taskElement.setAttribute('draggable', 'true'); // Re-enable dragging
        }

        // Saves the edited task data and updates the UI and Firestore
        async function saveEdit(taskElement, textInput, startTimeInput, endTimeInput) {
            let newText = textInput.value.trim();
            let newStartTime = startTimeInput.value;
            let newEndTime = endTimeInput.value;

            // --- Input Validation ---
            if (newText === '') {
                showToast('Task description cannot be empty.');
                textInput.focus();
                return;
            }

            // Time validation for edit:
            if (newStartTime || newEndTime) { // If either time field has a value
                if (!newStartTime) {
                    showToast('Please enter a start time if providing an end time, or leave both empty.');
                    startTimeInput.focus();
                    return;
                }
                if (!newEndTime) {
                    showToast('Please enter an end time if providing a start time, or leave both empty.');
                    endTimeInput.focus();
                    return;
                }
                if (newStartTime >= newEndTime) {
                    showToast('End time must be after start time.');
                    endTimeInput.focus();
                    return;
                }
                // Times are valid and provided
                taskElement.dataset.startTime = newStartTime;
                taskElement.dataset.endTime = newEndTime;
            } else {
                // Both newStartTime and newEndTime are empty, user wants to remove time
                delete taskElement.dataset.startTime;
                delete taskElement.dataset.endTime;
                // Ensure newStartTime and newEndTime are null for updatedDisplayData
                newStartTime = null;
                newEndTime = null;
            }
            // --- End Validation ---

            // Update the task element's dataset text
            taskElement.dataset.text = newText;
            const completionDate = taskElement.dataset.completionDate || null;

            // Update the display content within the task element
            const displayContent = taskElement.querySelector('.task-content-display');
            if (displayContent) {
                while (displayContent.firstChild) {
                    displayContent.removeChild(displayContent.firstChild);
                }
                const updatedDisplayData = { text: newText, startTime: newStartTime, endTime: newEndTime, completionDate: completionDate };
                const newDisplayNodes = createTaskDisplayContent(updatedDisplayData); // This returns a div
                while (newDisplayNodes.firstChild) { // Append children of the newDisplay div
                    displayContent.appendChild(newDisplayNodes.firstChild);
                }
            }

            // Handle progress bar for tasks in 'inprogress' column
            if (taskElement.closest('#inprogress')) {
                const progressContainer = taskElement.querySelector('.task-progress-container');
                if (newStartTime && newEndTime) { // Times are set
                    if (!progressContainer) { // Add progress bar if it doesn't exist
                        const newProgressElements = createProgressElements();
                        // Append before delete button if possible, otherwise just append
                        const deleteBtn = taskElement.querySelector('.delete-task-btn');
                        if (deleteBtn) {
                            taskElement.insertBefore(newProgressElements, deleteBtn);
                        } else {
                            taskElement.appendChild(newProgressElements);
                        }
                    }
                    updateSingleTaskTimer(taskElement); // Update timer immediately
                } else { // Times were removed
                    if (progressContainer) {
                        progressContainer.remove(); // Remove progress bar
                    }
                }
            }

            exitEditMode(taskElement); // Exit the editing UI
            await saveCurrentBoardState(); // Save the entire board state to Firestore
            console.log("Task edited and saved:", taskElement.id);
        }


        // Cancels the edit operation and restores the task element's original state
        function cancelEdit(taskElement) {
            exitEditMode(taskElement);
            console.log("Task edit cancelled:", taskElement.id);
        }

        // --- Daily Task Board Functions ---

        /**
         * Loads and displays tasks for a specific date on the Kanban board.
         * @param {string} dateString - The date in YYYY-MM-DD format.
         */
        async function displayTasksForDate(dateString) {
            currentSelectedDate = dateString; // Update the global state
            const formattedDate = formatDisplayDate(dateString); // Format for display
            selectedDateDisplay.textContent = `Loading tasks for ${formattedDate}...`; // Update UI
            
            if (dateSelector) dateSelector.value = dateString; // Sync date picker input
            clearBoard(); // Clear existing tasks from the board

            try {
                // Load tasks from Firestore or localStorage, but avoid duplication
                const tasksForDay = await loadTasksFromFirestore(dateString);

                // Update display message on successful load
                selectedDateDisplay.textContent = `Showing tasks for: ${formattedDate}`;

                // Populate Kanban columns with loaded tasks
                Object.keys(tasksForDay).forEach(columnId => {
                    const columnElement = document.getElementById(columnId);
                    const tasksContainer = columnElement?.querySelector('.tasks-container');
                    if (tasksContainer) {
                        // Create a Set to track unique task IDs to prevent duplicates
                        const addedTaskIds = new Set();
                        
                        tasksForDay[columnId].forEach(taskData => {
                            // Generate a consistent ID for deduplication
                            const taskId = taskData.id || 
                                       (taskData.text && `${taskData.text}-${taskData.startTime || ''}-${taskData.endTime || ''}`);
                            
                            // Only add if we haven't added this task already
                            if (taskId && !addedTaskIds.has(taskId)) {
                                addedTaskIds.add(taskId);
                                const taskElement = createTaskElement(taskData, columnId);
                                tasksContainer.appendChild(taskElement);
                            }
                        });
                    } else {
                        console.warn(`Tasks container not found in column "${columnId}".`);
                    }
                });

                checkAndMoveTasks(); // Check if tasks need to be moved based on current time
                updateInProgressTimers(); // Initialize/update progress timers

            } catch (error) {
                // Error is logged in detail within loadTasksFromFirestore
                console.error("Error in displayTasksForDate:", error);
                selectedDateDisplay.textContent = `Showing tasks for: ${formattedDate} (Offline)`;
                
                // We shouldn't need this fallback anymore since loadTasksFromFirestore already handles it
                // But keeping it as an extra safety measure
                const tasksForDay = loadTasksFromLocalStorage(dateString);
                
                // Use the same deduplication logic for localStorage fallback
                Object.keys(tasksForDay).forEach(columnId => {
                    const columnElement = document.getElementById(columnId);
                    const tasksContainer = columnElement?.querySelector('.tasks-container');
                    if (tasksContainer) {
                        const addedTaskIds = new Set();
                        
                        tasksForDay[columnId].forEach(taskData => {
                            const taskId = taskData.id || 
                                         (taskData.text && `${taskData.text}-${taskData.startTime || ''}-${taskData.endTime || ''}`);
                            
                            if (taskId && !addedTaskIds.has(taskId)) {
                                addedTaskIds.add(taskId);
                                const taskElement = createTaskElement(taskData, columnId);
                                tasksContainer.appendChild(taskElement);
                            }
                        });
                    }
                });
                
                checkAndMoveTasks();
                updateInProgressTimers();
            }
        }

        /**
         * Gathers the current state of all tasks on the board and saves it to Firestore
         * for the currently selected date.
         */
        async function saveCurrentBoardState() {
            // Check if a date is selected
            if (!currentSelectedDate) { 
                console.log("No date selected, cannot save daily state."); 
                return; 
            }

            // Prepare the data structure to save
            const tasksForCurrentDate = { todo: [], inprogress: [], done: [] };

            // Iterate through each column
            columns.forEach(column => {
                const columnId = column.id;
                const tasksContainer = column.querySelector('.tasks-container');
                // Check if the column ID is valid and the container exists
                if (tasksForCurrentDate.hasOwnProperty(columnId) && tasksContainer) {
                    // Iterate through each task element in the container
                    tasksContainer.querySelectorAll('.kanban-task').forEach(task => {
                        // Skip tasks currently being edited
                        if (task.classList.contains('editing')) {
                            console.warn("Skipping save for task in edit mode:", task.id);
                            return;
                        }
                        // Extract task data from dataset attributes
                        const taskData = {
                            text: task.dataset.text || '',
                            startTime: task.dataset.startTime || null, // Will be null if attribute not set
                            endTime: task.dataset.endTime || null,     // Will be null if attribute not set
                            // Retrieve completion date carefully, ensuring 'null' string isn't saved
                            completionDate: task.dataset.completionDate && task.dataset.completionDate !== 'null' ? task.dataset.completionDate : null
                        };
                        // Only save tasks that have text content
                        if (taskData.text) {
                            tasksForCurrentDate[columnId].push(taskData);
                        } else {
                            console.warn("Skipping saving daily task with no text:", task.id);
                        }
                    });
                } else if (!tasksContainer) {
                    console.warn(`Tasks container not found in column "${columnId}" during save.`);
                }
            });

            // Save to Firestore and localStorage
            try {
                await saveTasksToFirestore(currentSelectedDate, tasksForCurrentDate);
            } catch (error) {
                console.error("Error in saveCurrentBoardState:", error);
                // Already saved to localStorage in saveTasksToFirestore
            }
        }

        /**
         * Handles adding a new daily task from the form to the 'To Do' column.
         */
        async function addTask() {
            console.log("Add task called");
            
            // Get references to form elements
            const taskInput = document.getElementById('new-task-input');
            const startTimeInput = document.getElementById('new-task-start-time');
            const endTimeInput = document.getElementById('new-task-end-time');
            const todoColumn = document.getElementById('todo');
            const todoTasksContainer = todoColumn?.querySelector('.tasks-container');

            // Ensure all elements are found
            if (!taskInput || !startTimeInput || !endTimeInput || !todoTasksContainer) {
                console.error("Error: Daily task form/column elements not found.");
                showToast("Error: Could not find necessary form elements.");
                return;
            }

            // Get form input values
            const taskText = taskInput.value.trim();
            let startTime = startTimeInput.value; // Use let to potentially set to null
            let endTime = endTimeInput.value;     // Use let to potentially set to null

            if (taskText === '') {
                showToast('Please enter a task description.');
                taskInput.focus();
                return;
            }

            if (!currentSelectedDate) {
                showToast('Cannot add task: No date selected. Please select a date or refresh.');
                return;
            }

            // Time validation logic
            if (startTime || endTime) { // If either time field has a value
                if (!startTime) {
                    showToast('Please enter a start time if providing an end time.');
                    startTimeInput.focus();
                    return;
                }
                if (!endTime) {
                    showToast('Please enter an end time if providing a start time.');
                    endTimeInput.focus();
                    return;
                }
                if (startTime >= endTime) {
                    showToast('End time must be after start time.');
                    endTimeInput.focus();
                    return;
                }
                // Times are valid and provided
            } else {
                // Both startTime and endTime are empty, so set them to null for data consistency
                startTime = null;
                endTime = null;
            }

            // Create task data object
            const newTaskData = { text: taskText, startTime: startTime, endTime: endTime, completionDate: null };
            // Create the task element for the UI
            const newTaskElement = createTaskElement(newTaskData, 'todo');

            if (newTaskElement) {
                // Add the new task element to the 'To Do' column
                todoTasksContainer.appendChild(newTaskElement);
            } else {
                console.error("Error creating daily task element.");
                showToast("Error: Could not create the task visually.");
                return;
            }

            // Clear the form fields
            taskInput.value = '';
            startTimeInput.value = ''; // Clear time inputs regardless
            endTimeInput.value = '';   // Clear time inputs regardless

            // Save the updated board state to Firestore
            await saveCurrentBoardState();
            console.log(`Daily task added for "${taskText}", saving board state.`);

            checkAndMoveTasks(); // Check if the new task should be moved immediately (if times were provided)
        }



        // --- Drag and Drop Event Handlers ---

        // Called when dragging of a task starts
        function handleDragStart(event) {
            // Prevent dragging if the task is being edited
            if (event.target.classList.contains('kanban-task') && event.target.classList.contains('editing')) {
                event.preventDefault();
                return;
            }
            draggedElement = event.target; // Store the element being dragged
            draggedElementType = event.target.dataset.type; // Store its type
            event.dataTransfer.setData('text/plain', event.target.id); // Set data for the drag operation
            event.dataTransfer.effectAllowed = "move"; // Indicate that moving is allowed
            // Add dragging class slightly later for visual feedback
            setTimeout(() => {
                if (draggedElement) draggedElement.classList.add('dragging');
            }, 0);
            console.log(`Drag Start: ${draggedElementType} - ${draggedElement.id}`);
        }

        // Called when dragging of a task ends (successfully or cancelled)
        function handleDragEnd() {
            if (draggedElement) {
                draggedElement.classList.remove('dragging'); // Remove dragging style
                console.log(`Drag End: ${draggedElementType} - ${draggedElement.id}`);
            }
            // Clear state variables
            draggedElement = null;
            draggedElementType = null;
            // Remove drag-over styling from all columns
            columns.forEach(col => col.classList.remove('drag-over'));
        }

        // Called frequently as an element is dragged over a potential drop target
        function handleDragOver(event) {
            event.preventDefault(); // Necessary to allow dropping
            const targetColumn = event.target.closest('.kanban-column');
            const targetTask = event.target.closest('.kanban-task, .idea-task');

            // Prevent dropping onto a task that is being edited
            if (targetTask && targetTask.classList.contains('editing')) {
                event.dataTransfer.dropEffect = "none"; // Indicate dropping is not allowed
                return;
            }
            // Prevent dropping idea tasks onto 'In Progress' or 'Done' columns
            if (draggedElementType === 'idea-task' && targetColumn && (targetColumn.id === 'inprogress' || targetColumn.id === 'done')) {
                event.dataTransfer.dropEffect = "none";
                return;
            }

            event.dataTransfer.dropEffect = "move"; // Indicate dropping is allowed

            // Add visual feedback to the column being dragged over
            if (targetColumn && !targetColumn.classList.contains('drag-over')) {
                columns.forEach(col => col.classList.remove('drag-over')); // Remove from others
                targetColumn.classList.add('drag-over'); // Add to current target
            }
        }

        // Called when a dragged element leaves a potential drop target
        function handleDragLeave(event) {
            const targetColumn = event.target.closest('.kanban-column');
            // Remove drag-over style if the mouse leaves the column area
            if (targetColumn && !targetColumn.contains(event.relatedTarget)) {
                targetColumn.classList.remove('drag-over');
            }
        }

        // Called when a dragged element is dropped onto a valid drop target
        async function handleDrop(event) {
            event.preventDefault(); // Prevent default browser behavior
            const targetColumn = event.target.closest('.kanban-column');
            const targetTasksContainer = targetColumn?.querySelector('.tasks-container');
            const targetElement = event.target.closest('.kanban-task, .idea-task'); // Element being dropped onto (if any)

            targetColumn?.classList.remove('drag-over'); // Remove visual feedback

            // --- Validation checks ---
            if (!targetColumn || !targetTasksContainer || !draggedElement || !draggedElementType) {
                console.warn("Drop cancelled: Invalid target or no dragged element."); return;
            }
            if (targetElement && targetElement.classList.contains('editing')) {
                console.warn("Drop cancelled: Target element is being edited."); return;
            }
            // Prevent invalid drops (idea task to wrong column, dropping onto self)
            if (draggedElementType === 'idea-task' && (targetColumn.id === 'inprogress' || targetColumn.id === 'done')) {
                 console.warn("Drop cancelled: Idea tasks can only be dropped onto 'To Do'."); return;
            }
            if (draggedElement === targetElement) {
                 console.warn("Drop cancelled: Dropped onto self."); return;
            }
            // --- End Validation ---

            console.log(`Drop detected: ${draggedElementType} onto ${targetColumn.id}`);

            // --- Handle different drop scenarios ---

            // Scenario 1: Dropping an Idea Task onto the 'To Do' column
            if (draggedElementType === 'idea-task' && targetColumn.id === 'todo') {
                // Store idea data and show the time prompt modal
                ideaTaskToSchedule = { id: draggedElement.dataset.id, text: draggedElement.dataset.text };
                showTimePrompt(ideaTaskToSchedule.text);
                // The original idea task element remains in the Idea Box until scheduled via modal
            }
            // Scenario 2: Dropping a Kanban Task (moving between columns or reordering)
            else if (draggedElementType === 'kanban-task') {
                const previousColumn = draggedElement.parentElement.closest('.kanban-column');
                let completionDate = draggedElement.dataset.completionDate || null;

                // --- Update task state based on target column ---

                // Remove progress bar if moving out of 'In Progress'
                if (previousColumn?.id === 'inprogress' && targetColumn.id !== 'inprogress') {
                    const progressContainer = draggedElement.querySelector('.task-progress-container');
                    if (progressContainer) progressContainer.remove();
                }

                // Clear completion date if moving out of 'Done'
                if (targetColumn.id !== 'done') {
                    const existingDateSpan = draggedElement.querySelector('.task-completion-date');
                    if (existingDateSpan) existingDateSpan.remove();
                    delete draggedElement.dataset.completionDate; // Remove from dataset
                    completionDate = null;
                }

                // Handle moving into 'Done'
                if (targetColumn.id === 'done') {
                    // Set completion date if not already set
                    if (!completionDate) {
                        completionDate = getCurrentDateString(BOSTON_TIMEZONE);
                        draggedElement.dataset.completionDate = completionDate;
                    }
                    // Update or add the completion date display
                    const existingDateSpan = draggedElement.querySelector('.task-completion-date');
                    if (existingDateSpan) existingDateSpan.remove(); // Remove old one first
                    const dateSpan = document.createElement('span');
                    dateSpan.classList.add('task-completion-date');
                    dateSpan.textContent = `Completed: ${formatDisplayDate(completionDate)}`;
                    // Append after time info or at the end of display content
                    const timeInfo = draggedElement.querySelector('.task-time-info');
                    const displayContent = draggedElement.querySelector('.task-content-display');
                    if (timeInfo) {
                        timeInfo.insertAdjacentElement('afterend', dateSpan);
                    } else if (displayContent) {
                        displayContent.appendChild(dateSpan);
                    }
                    // Trigger confetti if moving into 'Done' from another column
                    if (previousColumn && previousColumn.id !== 'done' && myConfetti) {
                        triggerConfetti();
                    }
                }

                // Handle moving into 'In Progress'
                if (targetColumn.id === 'inprogress' && previousColumn?.id !== 'inprogress') {
                    // Add progress elements if the task has start/end times
                    if (draggedElement.dataset.startTime && draggedElement.dataset.endTime) {
                        if (!draggedElement.querySelector('.task-progress-container')) {
                            draggedElement.appendChild(createProgressElements());
                        }
                        updateSingleTaskTimer(draggedElement); // Update timer immediately
                    }
                }

                // --- Move the element in the DOM ---
                // Insert before the target element if dropped onto another task, otherwise append to the end
                if (targetElement && targetTasksContainer.contains(targetElement)) {
                    targetTasksContainer.insertBefore(draggedElement, targetElement);
                } else {
                    targetTasksContainer.appendChild(draggedElement);
                }

                // Save the new board state and update timers
                await saveCurrentBoardState();
                updateInProgressTimers();
            }
        }


        // --- Time Prompt Modal Functions ---

        // Shows the modal to set start/end times for a scheduled idea task
        function showTimePrompt(taskText) {
            if (!timePromptModal || !modalTaskText || !modalStartTimeInput || !modalEndTimeInput) return;
            modalTaskText.textContent = `Scheduling: "${taskText}"`; // Display task text
            modalStartTimeInput.value = ''; // Clear inputs
            modalEndTimeInput.value = '';
            timePromptModal.classList.add('active'); // Make modal visible
            modalStartTimeInput.focus(); // Focus the start time input
        }

        // Hides the time prompt modal and resets state
        function hideTimePrompt() {
            if (!timePromptModal) return;
            timePromptModal.classList.remove('active'); // Hide modal
            ideaTaskToSchedule = null; // Clear the task data being scheduled
            modalStartTimeInput.value = '';
            modalEndTimeInput.value = '';
        }

        // Handles saving the scheduled task from the modal
        async function handleModalSave() {
            // Ensure data and elements are available
            if (!ideaTaskToSchedule || !modalStartTimeInput || !modalEndTimeInput) {
                console.error("Cannot save modal: Missing task data or input elements.");
                hideTimePrompt(); return;
            }
            // Get and validate times
            const startTime = modalStartTimeInput.value;
            const endTime = modalEndTimeInput.value;
            if (!startTime) { showToast('Please enter a start time.'); modalStartTimeInput.focus(); return; }
            if (!endTime) { showToast('Please enter an end time.'); modalEndTimeInput.focus(); return; }
            if (startTime >= endTime) { showToast('End time must be after start time.'); modalEndTimeInput.focus(); return; }
            if (!currentSelectedDate) { showToast('Cannot schedule task: No date selected.'); hideTimePrompt(); return; }

            // Create data for the new Kanban task
            const newTaskData = {
                text: ideaTaskToSchedule.text,
                startTime: startTime,
                endTime: endTime,
                completionDate: null
            };
            // Create the UI element
            const newTaskElement = createTaskElement(newTaskData, 'todo');
            const todoColumn = document.getElementById('todo');
            const todoTasksContainer = todoColumn?.querySelector('.tasks-container');

            if (newTaskElement && todoTasksContainer) {
                // Add the new task to the 'To Do' column
                todoTasksContainer.appendChild(newTaskElement);
                // Save the updated board state
                await saveCurrentBoardState();
                console.log(`Scheduled idea task "${newTaskData.text}" for ${currentSelectedDate}`);

                // --- Delete the original idea task from storage and UI ---
                try {
                    console.log(`DEBUG: Deleting original idea task (ID: ${ideaTaskToSchedule.id}) after scheduling.`);
                    await deleteIdeaTaskFromFirestore(ideaTaskToSchedule.id);
                    const originalIdeaElement = document.getElementById(`idea-${ideaTaskToSchedule.id}`);
                    if (originalIdeaElement) {
                        originalIdeaElement.remove();
                        console.log(`DEBUG: Removed original idea task element from UI.`);
                    } else {
                        console.warn(`DEBUG: Could not find original idea task element (ID: idea-${ideaTaskToSchedule.id}) to remove from UI.`);
                    }
                } catch (error) {
                    console.error(`Error deleting original idea task (ID: ${ideaTaskToSchedule.id}) after scheduling:`, error);
                    // Inform user, but the main scheduling likely succeeded
                    showToast(`Task scheduled, but failed to remove the original from the Idea Box. Please remove it manually.`);
                }
                // --- End Deletion ---

                hideTimePrompt(); // Close the modal
            } else {
                console.error("Error creating or appending scheduled task element.");
                showToast("Error adding scheduled task to the board.");
                hideTimePrompt();
            }
        }


        // --- Other Core Functions ---

        // Triggers a confetti burst effect
        function triggerConfetti() {
            if (!myConfetti) return; // Ensure confetti is initialized
            myConfetti({
                particleCount: 200, // Number of confetti particles
                spread: 100, // How wide the confetti spreads
                origin: { y: 0.6 }, // Starting position (0.6 means 60% down the screen)
                colors: ['#f97316', '#ef4444', '#facc15', '#ffffff', '#a855f7'] // Custom colors
            });
        }

        // Archives a completed task to the 'hustle_archive' collection
        async function archiveTaskToFirestore(taskData) {
            if (!db || !hustleArchiveCollection) { 
                console.log("Skipping archive as Firestore is not available"); 
                return; 
            }
            
            // Ensure task has necessary data for archiving
            if (!taskData.completionDate || !taskData.text) {
                console.warn("Skipping archive for task missing completion date or text:", taskData);
                return;
            }
            
            // Add an 'archivedAt' timestamp
            const archiveData = {
                ...taskData,
                archivedAt: firebase.firestore.FieldValue.serverTimestamp()
            };
            
            try {
                await hustleArchiveCollection.add(archiveData); // Add to archive collection
                if (legacyArchiveCollection) {
                    await legacyArchiveCollection.add(archiveData).catch(()=>{});
                }
                console.log("Task archived to Firestore:", taskData.text);
            } catch (error) {
                console.error("Error archiving task to Firestore:", error);
            }
        }

        // Processes past dates, moves completed tasks to archive, and cleans up old documents
        async function runArchivingProcess() {
            if (!db || !hustleTasksCollection || !hustleArchiveCollection) {
                console.log("Skipping archiving as Firestore is not available");
                return false;
            }
            
            const todayDateStr = getCurrentDateString(BOSTON_TIMEZONE);
            let tasksArchived = false;
            console.log("Running archiving process...");

            try {
                // Query for documents in 'hustle_tasks' with IDs (dates) less than today's date
                let usingLegacy = false;
                let querySnapshot = await hustleTasksCollection.where(firebase.firestore.FieldPath.documentId(), "<", todayDateStr).get();
                if (querySnapshot.empty && legacyTasksCollection) {
                    querySnapshot = await legacyTasksCollection.where(firebase.firestore.FieldPath.documentId(), "<", todayDateStr).get();
                    if (!querySnapshot.empty) usingLegacy = true;
                }
                if (querySnapshot.empty) {
                    console.log("No past dates found with tasks to archive.");
                    return false; // Nothing to do
                }

                const batch = db.batch(); // Use a batch for efficient updates/deletes
                const archivePromises = []; // To track individual archive additions

                querySnapshot.forEach(doc => {
                    const dateString = doc.id;
                    const tasksForDay = doc.data();
                    let dayWasModified = false; // Flag if changes are made to this day's doc

                    // Process 'done' tasks for this past date
                    if (tasksForDay.done && Array.isArray(tasksForDay.done) && tasksForDay.done.length > 0) {
                        const tasksToKeepInDone = []; // Tasks that might remain (e.g., if missing completion date)
                        const tasksToArchive = [];    // Tasks to move to the archive collection

                        tasksForDay.done.forEach(taskData => {
                            // Only archive tasks that have a completion date
                            if (taskData.completionDate) {
                                tasksToArchive.push(taskData);
                                tasksArchived = true;
                                dayWasModified = true;
                            } else {
                                // Keep tasks without a completion date in the 'done' list (shouldn't happen ideally)
                                tasksToKeepInDone.push(taskData);
                                console.warn(`Task in 'done' column for ${dateString} lacks completion date:`, taskData.text);
                            }
                        });

                        // If tasks were marked for archiving, update the original document
                        if (dayWasModified) {
                            // Add individual archive operations (these happen outside the batch)
                            tasksToArchive.forEach(taskData => {
                                archivePromises.push(archiveTaskToFirestore(taskData));
                            });
                            // Update the original date document in the batch to remove the archived tasks
                            const docRef = usingLegacy ? legacyTasksCollection.doc(dateString) : hustleTasksCollection.doc(dateString);
                            batch.update(docRef, { done: tasksToKeepInDone });
                            console.log(`Marked document ${dateString} for update in batch (removing archived tasks).`);
                        }
                    }
                });

                // Commit all batched writes/updates/deletes
                await batch.commit();
                console.log("Batch update/delete committed successfully.");
                // Wait for all individual archive additions to settle
                await Promise.allSettled(archivePromises);
                console.log("Individual archive operations settled.");

            } catch (error) {
                console.error("Error during archiving process query or batch commit:", error);
            }
            
            console.log(`Archiving process finished. Tasks archived: ${tasksArchived}`);
            return tasksArchived;
        }

        // Generates the summary text for the previous day's completed tasks
        function generateSummaryText(tasks) {
            let taskSummary;
            if (!tasks || tasks.length === 0) {
                taskSummary = "Looks like there were no completed tasks logged for the previous day.";
            } else {
                const taskTexts = tasks.map(t => t.text || 'Unnamed Task');
                taskSummary = `Yesterday, you crushed ${tasks.length} task(s): `;
                // Format the list nicely
                if (taskTexts.length === 1) {
                    taskSummary += `<strong>${taskTexts[0]}</strong>.`;
                } else if (taskTexts.length === 2) {
                    taskSummary += `<strong>${taskTexts[0]}</strong> and <strong>${taskTexts[1]}</strong>.`;
                } else {
                    const lastTask = taskTexts.pop();
                    taskSummary += `<strong>${taskTexts.join('</strong>, <strong>')}</strong>, and <strong>${lastTask}</strong>.`;
                }
            }
            // Add a random motivational suffix
            if (motivationalSuffixes.length > 0) {
                currentSuffixIndex = (currentSuffixIndex + 1) % motivationalSuffixes.length;
                taskSummary += `<span class="motivation-suffix">${motivationalSuffixes[currentSuffixIndex]}</span>`;
            } else {
                taskSummary += `<span class="motivation-suffix">Keep up the great work!</span>`; // Fallback
            }
            return taskSummary;
        }

        // Fetches archived tasks for yesterday and displays the summary
        async function displayLatestSummary() {
            if (!db || !hustleArchiveCollection) { 
                console.log("Skipping summary display as Firestore archive is not available"); 
                dailySummaryDiv.classList.add('hidden'); 
                return; 
            }
            
            console.log("Fetching previous day's summary...");

            // Calculate yesterday's date string
            const today = new Date();
            const yesterday = new Date(today);
            yesterday.setDate(today.getDate() - 1);
            const yesterdayDateStr = yesterday.toISOString().split('T')[0]; // Format YYYY-MM-DD

            try {
                // Query the archive collection for tasks completed yesterday
                let querySnapshot = await hustleArchiveCollection.where("completionDate", "==", yesterdayDateStr).get();
                if (querySnapshot.empty && legacyArchiveCollection) {
                    querySnapshot = await legacyArchiveCollection.where("completionDate", "==", yesterdayDateStr).get();
                }
                const tasksForYesterday = [];
                querySnapshot.forEach(doc => {
                    tasksForYesterday.push(doc.data());
                });

                // Generate and display the summary text
                summaryContentP.innerHTML = generateSummaryText(tasksForYesterday);
                const summaryTitle = dailySummaryDiv.querySelector('h3');
                if (summaryTitle) summaryTitle.textContent = `Daily Wins Recap for ${formatDisplayDate(yesterdayDateStr)}!`;
                dailySummaryDiv.classList.remove('hidden'); // Show the summary section
                console.log(`Displaying summary for ${yesterdayDateStr} with ${tasksForYesterday.length} tasks.`);
            } catch (error) {
                console.error("Error fetching archived tasks for summary:", error);
                dailySummaryDiv.classList.add('hidden'); // Hide on error
            }
        }

        // Checks tasks in 'To Do' column and moves them to 'In Progress' if their start time has passed
        async function checkAndMoveTasks() {
            const todayDateStr = getCurrentDateString(BOSTON_TIMEZONE);
            // Only run this check if the currently viewed date is today
            if (currentSelectedDate !== todayDateStr) {
                return;
            }
            const currentTimeStr = getCurrentTimeString(BOSTON_TIMEZONE);

            // Get column elements
            const todoCol = document.getElementById('todo');
            const inProgressCol = document.getElementById('inprogress');
            if (!todoCol || !inProgressCol) { console.error("Cannot find columns for auto-move."); return; }
            const todoTasksContainer = todoCol.querySelector('.tasks-container');
            const inProgressTasksContainer = inProgressCol.querySelector('.tasks-container');
            if (!todoTasksContainer || !inProgressTasksContainer) { console.error("Cannot find task containers for auto-move."); return; }

            const tasksInTodo = todoTasksContainer.querySelectorAll('.kanban-task');
            let taskMoved = false; // Flag to check if any task was moved

            tasksInTodo.forEach(task => {
                if (task.classList.contains('editing')) { return; } // Skip tasks being edited
                const taskStartTime = task.dataset.startTime; // This will be undefined if no time was set
                // If task has a start time and the current time is past it
                if (taskStartTime && currentTimeStr >= taskStartTime) {
                    console.log(`Auto-moving task "${task.dataset.text}" (ID: ${task.id}) to In Progress`);
                    // Add progress elements if not already present and times exist
                    if (task.dataset.startTime && task.dataset.endTime && !task.querySelector('.task-progress-container')) {
                        task.appendChild(createProgressElements());
                    }
                    // Move the task element to the 'In Progress' container
                    inProgressTasksContainer.appendChild(task);
                    taskMoved = true;
                    // Add a temporary highlight class
                    task.classList.add('task-just-moved');
                    setTimeout(() => {
                        task.classList.remove('task-just-moved');
                    }, 1800); // Remove highlight after 1.8 seconds
                }
            });

            // If any task was moved, save the board state and update timers
            if (taskMoved) {
                await saveCurrentBoardState();
                updateInProgressTimers();
            }
        }

        // Displays a random motivational quote
        function displayMotivationalQuote() {
            if (!quoteDisplay || motivationalQuotes.length === 0) return;
            let randomIndex;
            // Ensure the new quote is different from the last one shown, if possible
            if (motivationalQuotes.length > 1) {
                do {
                    randomIndex = Math.floor(Math.random() * motivationalQuotes.length);
                } while (randomIndex === currentQuoteIndex);
            } else {
                randomIndex = 0; // Only one quote available
            }
            currentQuoteIndex = randomIndex; // Update the index
            quoteDisplay.textContent = motivationalQuotes[currentQuoteIndex]; // Set the text content
        }

        // --- In Progress Timer Update Functions ---

        // Updates the progress bar and remaining time for a single task
        function updateSingleTaskTimer(taskElement) {
            const progressBarFill = taskElement.querySelector('.progress-bar-fill');
            const remainingTimeSpan = taskElement.querySelector('.remaining-time');
            const startTimeStr = taskElement.dataset.startTime;
            const endTimeStr = taskElement.dataset.endTime;

            // Ensure necessary elements and data are present
            if (!progressBarFill || !remainingTimeSpan || !startTimeStr || !endTimeStr) {
                return Infinity; // Return a large number if data is missing
            }

            try {
                const now = new Date();
                // Create Date objects using the currently selected date and the task times
                const startDate = new Date(`${currentSelectedDate}T${startTimeStr}:00`);
                const endDate = new Date(`${currentSelectedDate}T${endTimeStr}:00`);

                // Validate dates
                if (isNaN(startDate) || isNaN(endDate) || endDate <= startDate) {
                    remainingTimeSpan.textContent = 'Invalid Time';
                    progressBarFill.style.width = '0%';
                    return Infinity;
                }

                // Calculate durations and percentage
                const totalDurationMillis = endDate - startDate;
                const elapsedMillis = now - startDate;
                const remainingMillis = endDate - now;
                let percentage = (elapsedMillis / totalDurationMillis) * 100;
                percentage = Math.max(0, Math.min(100, percentage)); // Clamp between 0 and 100

                // Update progress bar width
                progressBarFill.style.width = `${percentage}%`;

                // Update remaining time text
                const remainingSecondsTotal = Math.round(remainingMillis / 1000);
                remainingTimeSpan.classList.toggle('expired', remainingSecondsTotal < 0); // Add 'expired' class if time is up

                if (remainingSecondsTotal < 0) {
                    remainingTimeSpan.textContent = 'Time Up!';
                } else if (remainingSecondsTotal < 60) {
                    // Display seconds if less than a minute remains
                    remainingTimeSpan.textContent = `${remainingSecondsTotal}s left`;
                } else {
                    // Display minutes otherwise
                    const remainingMinutes = Math.ceil(remainingSecondsTotal / 60);
                    remainingTimeSpan.textContent = `${remainingMinutes}m left`;
                }
                return remainingSecondsTotal; // Return remaining seconds for interval adjustment

            } catch (e) {
                console.error("Error updating timer for task:", taskElement.id, e);
                remainingTimeSpan.textContent = 'Error';
                progressBarFill.style.width = '0%';
                return Infinity; // Return large number on error
            }
        }

        // Updates timers for all tasks currently in the 'In Progress' column
        function updateInProgressTimers() {
            const inProgressColumn = document.getElementById('inprogress');
            const tasksContainer = inProgressColumn?.querySelector('.tasks-container');
            if (!tasksContainer) return; // Exit if container not found

            const tasks = tasksContainer.querySelectorAll('.kanban-task');
            let isInLastMinute = false; // Flag if any task has < 60s remaining

            tasks.forEach(task => {
                 // Ensure progress elements exist if task should have them (has times)
                 if (task.dataset.startTime && task.dataset.endTime && !task.querySelector('.task-progress-container')) {
                     task.appendChild(createProgressElements());
                 }
                 // Update the timer for this task
                 const remainingSeconds = updateSingleTaskTimer(task);
                 // Check if this task triggers the need for faster updates
                 if (remainingSeconds >= 0 && remainingSeconds < 60) {
                     isInLastMinute = true;
                 }
            });

            // Adjust update interval based on whether any task is in its last minute
            if (isInLastMinute && !lastMinuteIntervalId) {
                // Switch to faster (1-second) updates
                clearInterval(progressTimerIntervalId); // Clear the slower interval
                progressTimerIntervalId = null;
                lastMinuteIntervalId = setInterval(updateInProgressTimers, LAST_MINUTE_INTERVAL);
                console.log("Starting last minute timer interval (1s).");
            } else if (!isInLastMinute && lastMinuteIntervalId) {
                // Switch back to slower updates if no tasks are in the last minute
                clearInterval(lastMinuteIntervalId); // Clear the faster interval
                lastMinuteIntervalId = null;
                // Restart the regular interval only if it's not already running
                if (!progressTimerIntervalId) {
                    progressTimerIntervalId = setInterval(updateInProgressTimers, TIMER_UPDATE_INTERVAL);
                    console.log("Stopping last minute timer, restarting regular interval (15s).");
                }
            }
        }

        // --- Initialize the app ---
        function initializeApp() {
            const currentBostonDate = getCurrentDateString(BOSTON_TIMEZONE);
            
            if (dateSelector) {
                dateSelector.value = currentBostonDate;
                try {
                    displayTasksForDate(currentBostonDate);
                } catch (error) {
                    console.error("Failed initial daily task load:", error);
                }
                
                dateSelector.addEventListener('change', async (event) => {
                    const oldDate = currentSelectedDate;
                    const newDate = event.target.value;
                    
                    if (oldDate === newDate) return; // Avoid useless saving if date didn't change
                    
                    // First save current board state
                    try {
                        await saveCurrentBoardState();
                        console.log(`Successfully saved board state for ${oldDate} before switching dates`);
                    } catch (error) {
                        console.error(`Error saving board state for ${oldDate} before switching dates:`, error);
                    }
                    
                    // Then clear the board before displaying the new date
                    clearBoard();
                    
                    // Now load the new date's tasks
                    displayTasksForDate(newDate);
                });
            } else {
                console.error("Date selector element not found.");
                try { displayTasksForDate(currentBostonDate); } catch (error) { /* Ignore */ }
            }

            try {
                displayIdeaTasks();
                displayLatestSummary();
            } catch(error) {
                console.error("Failed to display ideas or summary:", error);
            }

            // Set up event listeners for adding tasks
            const addTaskBtnLocal = document.getElementById('add-task-btn');
            if (addTaskBtnLocal) {
                addTaskBtnLocal.addEventListener('click', addTask);
                const dailyTaskInputs = ['new-task-input','new-task-start-time','new-task-end-time'];
                dailyTaskInputs.forEach(id => {
                    const input = document.getElementById(id);
                    if (input) input.addEventListener('keypress', (event) => { if (event.key === 'Enter') addTask(); });
                });
            } else { 
                console.error("Add daily task button not found."); 
            }

            if (addIdeaTaskBtn && ideaTaskInput) {
                addIdeaTaskBtn.addEventListener('click', addIdeaTask);
                ideaTaskInput.addEventListener('keypress', (event) => { if (event.key === 'Enter') addIdeaTask(); });
            } else { 
                console.error("Add idea task button or input not found."); 
            }

            if (modalSaveBtn) modalSaveBtn.addEventListener('click', handleModalSave);
            if (modalCancelBtn) modalCancelBtn.addEventListener('click', hideTimePrompt);

            // Set up intervals for checking tasks and updating timers
            if (taskCheckIntervalId) clearInterval(taskCheckIntervalId);
            taskCheckIntervalId = setInterval(checkAndMoveTasks, TASK_CHECK_INTERVAL);
            console.log(`Started task check interval (${TASK_CHECK_INTERVAL / 1000}s).`);

            if (progressTimerIntervalId) clearInterval(progressTimerIntervalId);
            if (lastMinuteIntervalId) clearInterval(lastMinuteIntervalId);
            progressTimerIntervalId = setInterval(updateInProgressTimers, TIMER_UPDATE_INTERVAL);
            console.log(`Started progress timer interval (${TIMER_UPDATE_INTERVAL / 1000}s).`);

            console.log("Initialization complete.");
        }

        // --- Service Worker Registration ---
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                // Get the base path - handles GitHub Pages repo paths
                let basePath = './';
                const pathSegments = window.location.pathname.split('/');
                if (window.location.hostname.includes('github.io') && pathSegments.length > 2) {
                    basePath = '/' + pathSegments[1] + '/';
                }
                
                navigator.serviceWorker.register('./service-worker.js', {
                    scope: basePath
                })
                .then(reg => {
                    console.log('Service Worker registration successful. Scope:', reg.scope);
                })
                .catch(err => {
                    console.error('Service Worker registration failed:', err);
                });
            });
        } else {
            console.warn('Service Workers not supported in this browser.');
        }

        // Initialize the time display
        updateTimeDisplay();
        setInterval(updateTimeDisplay, 60000); // Update every minute
        displayMotivationalQuote();

        // Check for remembered login on page load
        document.addEventListener('DOMContentLoaded', () => {
            checkRememberedLogin();
        });
    </script>
</body>
</html>
