<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SNG's Funky 3D Hustle Board</title>

    <script src="https://www.gstatic.com/firebasejs/9.6.7/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.7/firebase-firestore-compat.js"></script>

    <script src="https://cdn.tailwindcss.com"></script>

    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/dist/confetti.browser.min.js"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Poppins:wght@700;800&display=swap" rel="stylesheet">

    <link rel="manifest" href="manifest.json"> <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="SNG Board">
    <link rel="apple-touch-icon" href="icon-192.png"> <meta name="theme-color" content="#f97316">

    <style>
        /* --- CSS Styles --- */
        :root {
            /* Color variables */
            --column-bg: rgba(17, 24, 39, 0.75); --column-header-text: #f1f5f9;
            --task-bg: #ffffff; --task-text: #1f2937;
            --idea-task-bg: #e2e8f0; --idea-task-text: #334155;
            --accent-todo: #f59e0b; --accent-inprogress: #eab308; --accent-done: #22c55e;
            --button-primary-bg: #dc2626; --button-primary-hover: #b91c1c;
            --button-secondary-bg: #16a34a; --button-secondary-hover: #15803d;
            --button-cancel-bg: #64748b; --button-cancel-hover: #475569;
            --quote-bg: rgba(255, 255, 255, 0.1); --quote-border: rgba(255, 255, 255, 0.3); --quote-text: #f8fafc;
            --summary-bg: rgba(30, 41, 59, 0.8); --summary-header: #facc15; --summary-text: #cbd5e1; --summary-strong: #fde047;
            --idea-box-bg: rgba(51, 65, 85, 0.8);
            --modal-bg: rgba(17, 24, 39, 0.9); --modal-content-bg: #1f2937;
            --progress-bar-bg: #e5e7eb; /* gray-200 */
            --progress-bar-fill: var(--accent-inprogress); /* Use in-progress accent */
            --timer-text-color: #4b5563; /* gray-600 */
            --timer-text-expired-color: #dc2626; /* red-600 */
        }

        body {
            font-family: 'Inter', sans-serif;
            /* Consider adding a fallback background color or using a local image */
            background-image: url('https://raw.githubusercontent.com/sniting/sng-hustle-board./main/ChatGPT%20Image%20Apr%2030%2C%202025%20at%2007_19_36%20PM.png');
            background-size: cover; background-position: center center; background-repeat: no-repeat; background-attachment: fixed;
            background-color: #374151; /* Fallback color */
            padding: 2rem 1rem 5rem 1rem; color: var(--column-header-text);
            perspective: 1800px; overflow-x: hidden; min-height: 100vh;
        }
        h1, h2, h3 { font-family: 'Poppins', sans-serif; font-weight: 800; letter-spacing: 0.02em; }
        #main-content-wrapper { max-width: 1200px; margin: 0 auto; }
        #main-title { color: #ffffff; text-shadow: 2px 2px 4px rgba(0,0,0,0.6); animation: pulse-glow 3s infinite alternate; }
        #subtitle { color: #f1f5f9; text-shadow: 1px 1px 3px rgba(0,0,0,0.5); }
        @keyframes pulse-glow { from { text-shadow: 2px 2px 4px rgba(0,0,0,0.5), 0 0 5px rgba(255,255,255,0.3); } to { text-shadow: 2px 2px 6px rgba(0,0,0,0.6), 0 0 15px rgba(255,255,255,0.5); } }

        /* Kanban Column Styling */
        .kanban-column {
            min-height: 350px; background-color: var(--column-bg); backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 0.75rem; padding: 1.25rem;
            transition: all 0.35s cubic-bezier(0.25, 0.8, 0.25, 1); box-shadow: 0 10px 20px rgba(0, 0, 0, 0.25);
            transform: rotateX(2deg) rotateY(-1deg); display: flex; flex-direction: column;
        }
        .kanban-column:hover { transform: rotateX(0deg) rotateY(0deg) scale(1.03) translateZ(20px); box-shadow: 0 15px 35px rgba(0, 0, 0, 0.35); }
        .kanban-column h2 {
            color: var(--column-header-text); text-transform: uppercase; font-weight: 700; display: flex;
            align-items: center; justify-content: center; gap: 0.6rem; border-bottom: 2px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 0.75rem; margin-bottom: 1.25rem; flex-shrink: 0;
        }
        .tasks-container { flex-grow: 1; overflow-y: auto; min-height: 100px; padding-top: 5px; }

        /* Task Card Styling (Daily Tasks) */
        .kanban-task {
            background-color: var(--task-bg); color: var(--task-text); border-radius: 0.5rem;
            padding: 0.8rem 1.1rem; margin-bottom: 1rem; cursor: grab; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            transition: all 0.25s ease-in-out; word-break: break-word; position: relative;
            border-left: 5px solid var(--accent-todo);
        }
        #inprogress .kanban-task { border-left-color: var(--accent-inprogress); }
        #done .kanban-task { border-left-color: var(--accent-done); }

        .task-content-display {}
        .task-time-info { font-size: 0.8rem; color: #475569; margin-top: 0.4rem; display: block; font-weight: 600; }
        .task-time-info .duration { color: #57534e; margin-left: 0.5rem; font-weight: 500; }
        .task-completion-date { font-size: 0.75rem; color: #64748b; margin-top: 0.25rem; display: block; }

        /* In Progress Timer/Progress Bar Styles */
        .task-progress-container { margin-top: 0.75rem; height: 16px; display: flex; align-items: center; gap: 0.5rem; }
        .progress-bar { flex-grow: 1; height: 8px; background-color: var(--progress-bar-bg); border-radius: 4px; overflow: hidden; }
        .progress-bar-fill { height: 100%; width: 0%; background-color: var(--progress-bar-fill); border-radius: 4px; transition: width 0.5s ease-out; }
        .remaining-time { font-size: 0.75rem; font-weight: 500; color: var(--timer-text-color); white-space: nowrap; flex-shrink: 0; }
        .remaining-time.expired { color: var(--timer-text-expired-color); font-weight: 700; }

        .kanban-task:active:not(.editing) { cursor: grabbing; box-shadow: 0 8px 16px rgba(0, 0, 0, 0.15); transform: scale(1.03); }
        .dragging { opacity: 0.5; transform: rotate(5deg) scale(1.08) skew(-5deg, -2deg); }
        .idea-task.dragging { background-color: #a7f3d0; border: 1px dashed #059669; }
        .drag-over { background-color: rgba(70, 88, 116, 0.8); transform: scale(1.01); }

        /* Confetti Canvas Styling */
        #confetti-canvas { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 9999; }

        /* Time/Date/Quote Display Styling */
        #time-date-display, #selected-date-display, #motivational-quote { background-color: rgba(30, 41, 59, 0.6); backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.2); padding: 0.8rem 1.2rem; border-radius: 0.6rem; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15); text-align: center; margin-bottom: 1.5rem; max-width: 550px; margin-left: auto; margin-right: auto; color: #f1f5f9; font-weight: 600; text-shadow: 1px 1px 2px rgba(0,0,0,0.3); transition: all 0.3s ease-out; }
        #time-date-display:hover, #selected-date-display:hover, #motivational-quote:hover { transform: translateY(-4px) scale(1.02); box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2); }
        #selected-date-display { background-color: rgba(51, 65, 85, 0.7); color: #ffffff; font-weight: 700; margin-top: 0.5rem; border-color: rgba(255, 255, 255, 0.3); }
        #motivational-quote { background-color: rgba(17, 24, 39, 0.65); border: 1px solid var(--quote-border); color: var(--quote-text); padding: 1rem 1.2rem; font-size: 1rem; font-weight: 500; font-style: normal; text-shadow: 1px 1px 2px rgba(0,0,0,0.4); margin-bottom: 2rem; }

        /* Date Selector Styling */
        #date-selector-container { text-align: center; margin-bottom: 1.5rem; }
        #date-selector-container label { margin-right: 0.5rem; font-weight: 700; color: #f1f5f9; text-shadow: 1px 1px 2px rgba(0,0,0,0.3); }
        #date-selector { padding: 0.6rem 0.8rem; border: 1px solid rgba(255,255,255,0.3); border-radius: 0.5rem; box-shadow: inset 0 1px 3px 0 rgba(0,0,0,0.1); cursor: pointer; background-color: rgba(30, 41, 59, 0.7); color: #ffffff; font-weight: 500; }

        /* Add Task Form Container Styling */
         #add-task-form-container { background-color: rgba(30, 41, 59, 0.85); backdrop-filter: blur(12px); border: 1px solid rgba(255, 255, 255, 0.2); padding: 1.75rem; border-radius: 0.75rem; box-shadow: 0 8px 20px rgba(0, 0, 0, 0.25); transition: all 0.35s cubic-bezier(0.25, 0.8, 0.25, 1); transform: rotateX(1deg) rotateY(1deg); margin-bottom: 2.5rem; }
         #add-task-form-container:hover { transform: rotateX(0deg) rotateY(0deg) scale(1.02) translateZ(15px); box-shadow: 0 12px 25px rgba(0, 0, 0, 0.3); }
        #add-task-form { display: grid; grid-template-columns: 1fr 1fr; gap: 0.75rem; align-items: end; }
        #add-task-form > div:nth-child(1) { grid-column: span 2; }
        #add-task-form > div:nth-child(4) { grid-column: span 2; margin-top: 0.5rem; }
        @media (min-width: 768px) { #add-task-form { grid-template-columns: minmax(150px, 3fr) 1fr 1fr auto; gap: 1rem; } #add-task-form > div:nth-child(1) { grid-column: auto; } #add-task-form > div:nth-child(4) { grid-column: auto; margin-top: 0; } }
        #add-task-form label { display: block; font-size: 0.9rem; font-weight: 600; color: #cbd5e1; margin-bottom: 0.4rem; }
        #add-task-form input[type="text"], #add-task-form input[type="time"] { width: 100%; border: 1px solid #475569; border-radius: 0.5rem; padding: 0.6rem 0.9rem; box-shadow: inset 0 1px 3px 0 rgba(0,0,0,0.1); font-size: 0.9rem; background-color: #1e293b; color: #f1f5f9; }
        #add-task-form button { background-color: var(--button-primary-bg); color: white; font-weight: 700; padding: 0.6rem 1.5rem; border-radius: 0.5rem; transition: all 0.2s ease-in-out; box-shadow: 0 3px 6px rgba(0,0,0,0.15); border: none; cursor: pointer; text-transform: uppercase; }
        #add-task-form button:hover { background-color: var(--button-primary-hover); transform: translateY(-2px) scale(1.02); box-shadow: 0 5px 10px rgba(0,0,0,0.2); }

        /* Idea Box Styling */
        #idea-box-container { background-color: var(--idea-box-bg); backdrop-filter: blur(10px); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 0.75rem; padding: 1.5rem; margin-top: 2.5rem; margin-bottom: 2.5rem; max-width: 6xl; margin-left: auto; margin-right: auto; box-shadow: 0 6px 15px rgba(0, 0, 0, 0.2); }
        #idea-box-container h3 { color: #e0f2fe; text-align: center; margin-bottom: 1rem; font-weight: 700; text-shadow: 1px 1px 2px rgba(0,0,0,0.3); }
        #add-idea-form { display: flex; gap: 0.75rem; margin-bottom: 1.25rem; }
        #idea-task-input { flex-grow: 1; border: 1px solid #475569; border-radius: 0.5rem; padding: 0.6rem 0.9rem; box-shadow: inset 0 1px 3px 0 rgba(0,0,0,0.1); font-size: 0.9rem; background-color: #1e293b; color: #f1f5f9; }
        #add-idea-task-btn { background-color: var(--button-secondary-bg); color: white; font-weight: 600; padding: 0.6rem 1.2rem; border-radius: 0.5rem; transition: all 0.2s ease-in-out; box-shadow: 0 2px 5px rgba(0,0,0,0.15); border: none; cursor: pointer; white-space: nowrap; }
        #add-idea-task-btn:hover { background-color: var(--button-secondary-hover); transform: translateY(-1px) scale(1.02); box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
        #idea-task-list { max-height: 250px; overflow-y: auto; padding-right: 5px; }
        .idea-task { background-color: var(--idea-task-bg); color: var(--idea-task-text); border-radius: 0.375rem; padding: 0.6rem 0.9rem; margin-bottom: 0.75rem; cursor: grab; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08); transition: all 0.2s ease-in-out; word-break: break-word; position: relative; display: flex; justify-content: space-between; align-items: center; border-left: 4px solid #60a5fa; }
         .idea-task span { flex-grow: 1; margin-right: 0.5rem; }
        .idea-task:active { cursor: grabbing; }
        .delete-idea-task-btn { background: none; border: none; color: #ef4444; font-size: 1.1rem; line-height: 1; cursor: pointer; padding: 0.1rem 0.2rem; opacity: 0.5; transition: all 0.2s ease; flex-shrink: 0; }
        .idea-task:hover .delete-idea-task-btn { opacity: 1; }
        .delete-idea-task-btn:hover { transform: scale(1.2); color: #b91c1c; }

        /* Daily Summary Styling */
        #daily-summary { background-color: var(--summary-bg); border: 1px solid rgba(255, 255, 255, 0.15); padding: 1.5rem; border-radius: 0.75rem; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); margin-top: 2.5rem; max-width: 6xl; margin-left: auto; margin-right: auto; }
        #daily-summary h3 { color: var(--summary-header); font-weight: 700; margin-bottom: 0.75rem; }
        #daily-summary p { color: var(--summary-text); font-size: 0.95rem; line-height: 1.6; }
        #daily-summary strong { font-weight: 700; color: var(--summary-strong); }
        #daily-summary .motivation-suffix { display: block; margin-top: 1rem; font-style: italic; color: #93c5fd; }

        /* Edit/Delete Styles (for daily tasks) */
        .task-edit-form { display: flex; flex-direction: column; gap: 0.6rem; }
        .task-edit-form input[type="text"], .task-edit-form input[type="time"] { width: 100%; border: 1px solid #94a3b8; border-radius: 0.375rem; padding: 0.4rem 0.6rem; font-size: 0.875rem; background-color: #f8fafc; color: #1e293b; }
        .task-edit-form .edit-time-inputs { display: flex; gap: 0.6rem; }
        .task-edit-form .edit-time-inputs > div { flex-grow: 1; }
        .task-edit-form .edit-buttons { display: flex; justify-content: flex-end; gap: 0.6rem; margin-top: 0.6rem; }
        .task-edit-form button { padding: 0.3rem 0.7rem; border-radius: 0.375rem; font-size: 0.8rem; font-weight: 700; transition: all 0.2s ease; border: none; cursor: pointer; text-transform: uppercase; }
        .edit-save-btn { background-color: var(--button-secondary-bg); color: white; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .edit-save-btn:hover { background-color: var(--button-secondary-hover); transform: scale(1.05); box-shadow: 0 3px 6px rgba(0,0,0,0.15); }
        .edit-cancel-btn { background-color: var(--button-cancel-bg); color: #1e293b; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        .edit-cancel-btn:hover { background-color: var(--button-cancel-hover); transform: scale(1.05); box-shadow: 0 3px 6px rgba(0,0,0,0.15); }
        .delete-task-btn { position: absolute; top: 0.4rem; right: 0.4rem; background: none; border: none; color: #fca5a5; font-size: 1.2rem; line-height: 1; cursor: pointer; padding: 0.1rem; opacity: 0.4; transition: all 0.2s ease; }
        .kanban-task:hover .delete-task-btn { opacity: 0.8; }
        .delete-task-btn:hover { opacity: 1; color: #ef4444; transform: scale(1.15) rotate(10deg); }
        .kanban-task.editing { cursor: default; border-left-color: var(--button-primary-bg); }

        /* Highlight effect for auto-moved tasks */
        .task-just-moved { background-color: rgba(250, 204, 21, 0.3); animation: highlight-fade 1.8s ease-out; }
        @keyframes highlight-fade { 0% { background-color: rgba(250, 204, 21, 0.6); } 100% { background-color: var(--task-bg); } }

        /* Time Prompt Modal Styling */
        #time-prompt-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); backdrop-filter: blur(5px); display: none; align-items: center; justify-content: center; z-index: 10000; }
        #time-prompt-modal.active { display: flex; }
        .modal-content { background-color: var(--modal-content-bg); padding: 2rem; border-radius: 0.75rem; box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4); width: 90%; max-width: 400px; border: 1px solid rgba(255, 255, 255, 0.2); }
        .modal-content h3 { color: #e0f2fe; text-align: center; margin-bottom: 1.5rem; font-size: 1.25rem; }
        .modal-content label { display: block; font-size: 0.9rem; font-weight: 600; color: #cbd5e1; margin-bottom: 0.4rem; margin-top: 1rem; }
        .modal-content input[type="time"] { width: 100%; border: 1px solid #475569; border-radius: 0.5rem; padding: 0.6rem 0.9rem; box-shadow: inset 0 1px 3px 0 rgba(0,0,0,0.1); font-size: 0.9rem; background-color: #334155; color: #f1f5f9; }
        .modal-buttons { display: flex; justify-content: flex-end; gap: 0.75rem; margin-top: 2rem; }
        .modal-buttons button { padding: 0.5rem 1.2rem; border-radius: 0.5rem; font-weight: 700; transition: all 0.2s ease; border: none; cursor: pointer; text-transform: uppercase; font-size: 0.9rem; }
        #modal-save-btn { background-color: var(--button-secondary-bg); color: white; }
        #modal-save-btn:hover { background-color: var(--button-secondary-hover); transform: scale(1.03); }
        #modal-cancel-btn { background-color: var(--button-cancel-bg); color: white; }
        #modal-cancel-btn:hover { background-color: var(--button-cancel-hover); transform: scale(1.03); }

    </style>
</head>
<body class="p-4 md:p-8">

    <div id="main-content-wrapper">

        <h1 id="main-title" class="text-5xl font-extrabold text-center mb-2">SNG's Hustle Board</h1>
        <p id="subtitle" class="text-center text-lg mb-6">Plan & Conquer.</p>

        <div id="time-date-display" class="text-base">Loading time...</div>
        <div id="motivational-quote">Loading inspiration...</div>
        <div id="date-selector-container">
            <label for="date-selector">Select Date:</label>
            <input type="date" id="date-selector">
        </div>
        <div id="selected-date-display" class="text-lg">Loading tasks for...</div>

        <div class="mb-10 max-w-xl mx-auto" id="add-task-form-container">
            <h2 class="text-2xl font-bold mb-5 text-center text-slate-100">Add New Hustle (Today)</h2>
            <div id="add-task-form">
                <div>
                    <label for="new-task-input">Task:</label>
                    <input type="text" id="new-task-input" placeholder="Define the next victory..." class="focus:outline-none focus:ring-2 focus:ring-red-500 focus:border-transparent">
                </div>
                <div>
                    <label for="new-task-start-time">Start (Optional):</label>
                    <input type="time" id="new-task-start-time" class="focus:outline-none focus:ring-2 focus:ring-red-500 focus:border-transparent">
                </div>
                <div>
                    <label for="new-task-end-time">End (Optional):</label>
                    <input type="time" id="new-task-end-time" class="focus:outline-none focus:ring-2 focus:ring-red-500 focus:border-transparent">
                </div>
                <div>
                    <button id="add-task-btn" class="w-full">Lock It In</button>
                </div>
            </div>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-8 max-w-6xl mx-auto">
            <div id="todo" class="kanban-column" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event)">
                <h2 class="text-xl mb-5">🎯 To Do</h2>
                <div class="tasks-container">
                </div>
            </div>
            <div id="inprogress" class="kanban-column" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event)">
                <h2 class="text-xl mb-5">🔥 In Progress</h2>
                 <div class="tasks-container">
                </div>
            </div>
            <div id="done" class="kanban-column" ondragover="handleDragOver(event)" ondragleave="handleDragLeave(event)" ondrop="handleDrop(event)">
                <h2 class="text-xl mb-5">🏆 Done!</h2>
                 <div class="tasks-container">
                </div>
            </div>
        </div>

        <div id="idea-box-container">
            <h3 class="text-xl font-bold">💡 Idea Box (Unscheduled Tasks)</h3>
            <div id="add-idea-form">
                <input type="text" id="idea-task-input" placeholder="Capture a new idea..." class="focus:outline-none focus:ring-2 focus:ring-blue-400 focus:border-transparent">
                <button id="add-idea-task-btn">Add Idea</button>
            </div>
            <div id="idea-task-list">
                <p class="text-slate-400 text-center italic">Loading ideas...</p>
            </div>
        </div>

        <div id="daily-summary" class="hidden"> <h3 class="text-xl font-bold">Daily Wins Recap!</h3>
            <p id="summary-content">No summary available yet.</p>
        </div>

    </div> <canvas id="confetti-canvas"></canvas>

    <div id="time-prompt-modal">
        <div class="modal-content">
            <h3>Schedule Idea Task</h3>
            <p id="modal-task-text" class="text-slate-300 mb-4 text-center"></p> <div>
                <label for="modal-start-time">Start Time:</label>
                <input type="time" id="modal-start-time">
            </div>
            <div>
                <label for="modal-end-time">End Time:</label>
                <input type="time" id="modal-end-time">
            </div>
            <div class="modal-buttons">
                <button id="modal-cancel-btn">Cancel</button>
                <button id="modal-save-btn">Save to Schedule</button>
            </div>
        </div>
    </div>
    <script>
        // --- Firebase Configuration ---
        // Using the config provided by the user for sng-hustle-board-standalone
        const firebaseConfig = {
         apiKey: "AIzaSyBygcOaz8etf0XycZ4ILTrUkSXD-SKhFVM", // Replace with your actual API key if needed
         authDomain: "sng-hustle-board-standalone.firebaseapp.com",
         projectId: "sng-hustle-board-standalone",
         storageBucket: "sng-hustle-board-standalone.appspot.com",
         messagingSenderId: "892064086812",
         appId: "1:892064086812:web:4f0aeec9a6bd24c92958d9"
        };
        // --- End Firebase Configuration ---


        // --- Initialize Firebase ---
        let db;
        try {
            // Initialize Firebase App if it hasn't been initialized yet
            if (!firebase.apps.length) {
                 firebase.initializeApp(firebaseConfig);
            } else {
                 firebase.app(); // if already initialized, use that app
            }
            // Get Firestore instance
            db = firebase.firestore();
            console.log("Firebase initialized successfully with sng-hustle-board-standalone config.");
        } catch (error) {
            console.error("Firebase initialization failed:", error);
            // Display a prominent error message on the page if initialization fails
            const errorDiv = document.createElement('div');
            errorDiv.textContent = "CRITICAL ERROR: Could not initialize Firebase. Check configuration and console logs.";
            errorDiv.style.cssText = 'background-color: #b91c1c; color: white; padding: 15px; text-align: center; position: fixed; top: 0; left: 0; width: 100%; z-index: 10000; font-weight: bold;';
            document.body.prepend(errorDiv);
            // Optionally disable all functionality by disabling buttons/inputs
            // document.querySelectorAll('button, input').forEach(el => el.disabled = true);
        }

        // --- Firestore Collection References ---
        // Get references to Firestore collections only if db was initialized successfully
        const hustleTasksCollection = db ? db.collection("hustle_tasks") : null; // For daily scheduled tasks
        const hustleArchiveCollection = db ? db.collection("hustle_archive") : null; // For archived tasks
        const hustleIdeaBoxCollection = db ? db.collection("hustle_ideaBoxTasks") : null; // For unscheduled idea tasks

        // --- Constants ---
        const BOSTON_TIMEZONE = 'America/New_York'; // Timezone for date/time operations
        const TASK_CHECK_INTERVAL = 60000; // Check tasks every 60 seconds (1 minute)
        const TIMER_UPDATE_INTERVAL = 15000; // Update in-progress timers every 15 seconds
        const LAST_MINUTE_INTERVAL = 1000; // Update timers every second when less than a minute remains

        // --- Motivational Quotes & Suffixes ---
        const motivationalQuotes = [
            "The mind is everything. What you think you become. - Buddha",
            "Whether you think you can, or you think you can't – you're right. - Henry Ford",
            "The only limit to our realization of tomorrow will be our doubts of today. - Franklin D. Roosevelt",
            "Your time is limited, so don't waste it living someone else's life. - Steve Jobs",
            "The trouble is, you think you have time. - Buddha",
            "Lost time is never found again. - Benjamin Franklin",
            "Time is what we want most, but what we use worst. - William Penn",
            "The purpose of life, after all, is to live it, to taste experience to the utmost, to reach out eagerly and without fear for newer and richer experience. - Eleanor Roosevelt",
            "Life is not a problem to be solved, but a reality to be experienced. - Soren Kierkegaard",
            "In the end, it's not the years in your life that count. It's the life in your years. - Abraham Lincoln",
            "Get busy living or get busy dying. - Stephen King (from The Shawshank Redemption)",
            "Very little is needed to make a happy life; it is all within yourself, in your way of thinking. - Marcus Aurelius",
            "You have power over your mind – not outside events. Realize this, and you will find strength. - Marcus Aurelius",
            "The two most important days in your life are the day you are born and the day you find out why. - Mark Twain",
            "Don't be pushed around by the fears in your mind. Be led by the dreams in your heart. - Roy T. Bennett"
        ];
        let currentQuoteIndex = -1; // To track the last shown quote index
        const motivationalSuffixes = [
            "Each step forward, no matter how small, builds momentum towards the happy, healthy, and abundant life you're creating. Keep going!", "Remember why you started! Every completed task is a brick laid on the foundation of your dream life – full of joy, well-being, and success.", "You're not just checking boxes; you're actively crafting a future filled with health, wealth, and happiness. Celebrate the progress!", "This hustle is fueling your journey towards enjoying every moment, backed by fitness and financial freedom. Awesome work!", "Stay focused on the vision: a vibrant life filled with health, prosperity, and genuine enjoyment. Today's wins are paving the way!"
        ];
        let currentSuffixIndex = -1; // To track the last shown summary suffix

        // --- DOM Elements ---
        // Get references to frequently used DOM elements
        const columns = document.querySelectorAll('.kanban-column');
        const timeDateDisplay = document.getElementById('time-date-display');
        const dateSelector = document.getElementById('date-selector');
        const selectedDateDisplay = document.getElementById('selected-date-display');
        const dailySummaryDiv = document.getElementById('daily-summary');
        const summaryContentP = document.getElementById('summary-content');
        const confettiCanvas = document.getElementById('confetti-canvas');
        const quoteDisplay = document.getElementById('motivational-quote');
        const ideaTaskInput = document.getElementById('idea-task-input');
        const addIdeaTaskBtn = document.getElementById('add-idea-task-btn');
        const ideaTaskList = document.getElementById('idea-task-list');
        const timePromptModal = document.getElementById('time-prompt-modal');
        const modalTaskText = document.getElementById('modal-task-text');
        const modalStartTimeInput = document.getElementById('modal-start-time');
        const modalEndTimeInput = document.getElementById('modal-end-time');
        const modalSaveBtn = document.getElementById('modal-save-btn');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');

        // --- Confetti Setup ---
        let myConfetti = null;
        // Initialize confetti only if the library is loaded
        if (typeof confetti !== 'undefined') {
             myConfetti = confetti.create(confettiCanvas, { resize: true, useWorker: true });
        } else {
             console.warn("Confetti library not loaded.");
        }

        // --- State Variables ---
        let draggedElement = null;      // Stores the element being dragged
        let draggedElementType = null;  // Stores the type ('kanban-task' or 'idea-task') of the dragged element
        let currentSelectedDate = '';   // Stores the currently selected date string (YYYY-MM-DD)
        let taskCheckIntervalId = null; // Stores the interval ID for checking task start times
        let progressTimerIntervalId = null; // Stores the interval ID for updating progress bars
        let lastMinuteIntervalId = null; // Stores the interval ID for faster updates in the last minute
        let ideaTaskToSchedule = null;  // Stores idea task data when prompting for time

        // --- Utility Functions ---

        // Gets the current date in YYYY-MM-DD format for a given timezone
        function getCurrentDateString(timeZone) {
            const now = new Date();
            const formatter = new Intl.DateTimeFormat('en-CA', { // en-CA format is YYYY-MM-DD
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                timeZone: timeZone
            });
            return formatter.format(now);
        }

        // Gets the current time in HH:MM (24-hour) format for a given timezone
        function getCurrentTimeString(timeZone) {
            const now = new Date();
            const formatter = new Intl.DateTimeFormat('en-GB', { // en-GB uses 24-hour format
                hour: '2-digit',
                minute: '2-digit',
                hour12: false,
                timeZone: timeZone
            });
            return formatter.format(now);
        }

        // Formats the current date and time for display (e.g., "Wednesday, April 30, 2025, 4:23 PM EDT")
        function formatLiveDateTime(timeZone) {
            const now = new Date();
            const options = {
                weekday: 'long', year: 'numeric', month: 'long', day: 'numeric',
                hour: 'numeric', minute: '2-digit', timeZoneName: 'short',
                timeZone: timeZone
            };
            return now.toLocaleString('en-US', options);
        }

        // Formats a YYYY-MM-DD date string into a more readable format (e.g., "April 30, 2025")
        function formatDisplayDate(dateString) {
            if (!dateString || !/^\d{4}-\d{2}-\d{2}$/.test(dateString)) return "Invalid Date";
            const [year, month, day] = dateString.split('-');
            // Use UTC to avoid timezone issues when creating the date object from parts
            const date = new Date(Date.UTC(Number(year), Number(month) - 1, Number(day)));
            const options = { year: 'numeric', month: 'long', day: 'numeric', timeZone: 'UTC' };
            return date.toLocaleDateString('en-US', options);
        }

        // Calculates the duration between two HH:MM time strings (e.g., "1h 30m")
        function calculateDuration(startTime, endTime) {
            if (!startTime || !endTime) return "";
            try {
                // Create date objects on a common date to compare times
                const start = new Date(`1970-01-01T${startTime}:00`);
                const end = new Date(`1970-01-01T${endTime}:00`);
                if (isNaN(start) || isNaN(end) || end <= start) return ""; // Invalid or end time is not after start time

                let diffMillis = end - start;
                const hours = Math.floor(diffMillis / (1000 * 60 * 60));
                diffMillis -= hours * (1000 * 60 * 60);
                const minutes = Math.floor(diffMillis / (1000 * 60));

                let durationStr = "";
                if (hours > 0) durationStr += `${hours}h `;
                if (minutes > 0) durationStr += `${minutes}m`;
                return durationStr.trim();
            } catch (e) {
                console.error("Error calculating duration:", e);
                return ""; // Return empty string on error
            }
        }

        // Formats an HH:MM time string into 12-hour format with AM/PM
        function formatTimeTo12Hour(timeString) {
            if (!timeString || !/^\d{2}:\d{2}$/.test(timeString)) {
                return timeString; // Return original if format is invalid
            }
            const [hours, minutes] = timeString.split(':');
            const hourNum = parseInt(hours, 10);
            const ampm = hourNum >= 12 ? 'PM' : 'AM';
            let hour12 = hourNum % 12;
            if (hour12 === 0) { // Handle midnight (00:xx) and noon (12:xx)
                hour12 = 12;
            }
            return `${hour12}:${minutes} ${ampm}`;
        }


        // --- Data Management Functions (Firestore) ---

        /**
         * Loads tasks for a specific date from the 'hustle_tasks' collection.
         * Includes detailed error logging.
         * @param {string} dateString - The date in YYYY-MM-DD format.
         * @returns {Promise<object>} A promise that resolves to an object {todo: [], inprogress: [], done: []}.
         * @throws {Error} If Firestore is not initialized or if loading fails.
         */
        async function loadTasksFromFirestore(dateString) {
            // Check if Firestore is initialized
            if (!db || !hustleTasksCollection) {
                const errorMsg = "Firestore 'hustle_tasks' collection not initialized when loading tasks.";
                console.error(errorMsg);
                throw new Error(errorMsg);
            }

            console.log(`Attempting to load daily tasks for date: ${dateString}...`);
            // Validate the date string format
            if (!dateString || typeof dateString !== 'string' || !/^\d{4}-\d{2}-\d{2}$/.test(dateString)) {
                console.error(`Invalid dateString provided to loadTasksFromFirestore: ${dateString}`);
                alert(`Internal Error: Invalid date format used (${dateString}). Cannot load tasks.`);
                throw new Error(`Invalid dateString: ${dateString}`);
            }
            // Get a reference to the specific date document
            const docRef = hustleTasksCollection.doc(dateString);

            try {
                console.log(`Fetching document: ${docRef.path}`);
                const docSnap = await docRef.get(); // Attempt to get the document

                if (docSnap.exists) { // Check the boolean property for Compat SDK
                    console.log(`Document found for ${dateString}. Data:`, docSnap.data());
                    const data = docSnap.data() || {}; // Use empty object if data is null/undefined

                    // Validate the structure of the data, providing defaults if fields are missing/invalid
                    const tasks = {
                        todo: Array.isArray(data.todo) ? data.todo : [],
                        inprogress: Array.isArray(data.inprogress) ? data.inprogress : [],
                        done: Array.isArray(data.done) ? data.done : []
                    };
                    console.log(`Successfully processed tasks for ${dateString}.`);
                    return tasks;
                } else {
                    // Document doesn't exist for this date
                    console.log(`No document found for ${dateString}, returning empty task lists.`);
                    return { todo: [], inprogress: [], done: [] }; // Return empty structure
                }
            } catch (error) {
                // Log detailed error information if the fetch fails
                console.error(`❌❌❌ ERROR loading daily tasks document for ${dateString}:`, error);
                console.error("Error Code:", error.code);
                console.error("Error Message:", error.message);

                // Show a user-friendly alert
                alert(`Failed to load tasks for ${formatDisplayDate(dateString)}. Check console for details (F12 -> Console).`);

                // Re-throw the error so the calling function knows it failed
                throw error;
            }
        }


        /**
         * Saves the current state of the Kanban board for a specific date to Firestore.
         * Overwrites the existing document for that date.
         * @param {string} dateString - The date in YYYY-MM-DD format.
         * @param {object} tasksForDate - An object {todo: [], inprogress: [], done: []} containing task data.
         */
        async function saveTasksToFirestore(dateString, tasksForDate) {
             // Check if Firestore is initialized
             if (!db || !hustleTasksCollection) { console.error("Firestore 'hustle_tasks' collection not initialized."); return; }
             // Validate the date string format
             if (!dateString || typeof dateString !== 'string' || !/^\d{4}-\d{2}-\d{2}$/.test(dateString)) {
                 console.error(`Invalid dateString provided to saveTasksToFirestore: ${dateString}. Aborting save.`);
                 alert(`Internal Error: Invalid date format used (${dateString}). Cannot save tasks.`);
                 return;
             }
             console.log(`Attempting to save daily tasks for ${dateString}... Data:`, tasksForDate);
             // Get a reference to the specific date document
             const docRef = hustleTasksCollection.doc(dateString);
             try {
                 // Use set() to completely overwrite the document with the new state
                 await docRef.set(tasksForDate);
                 console.log("Daily tasks successfully saved for date:", dateString);
             } catch (error) {
                 // Log detailed error information if saving fails
                 console.error(`❌❌❌ Error saving daily tasks for ${dateString}:`, error);
                 console.error("Error Code:", error.code);
                 console.error("Error Message:", error.message);
                 alert(`Error saving daily tasks for ${formatDisplayDate(dateString)}. Check console for details.`);
             }
         }

        /**
         * Loads all tasks from the 'hustle_ideaBoxTasks' collection, ordered by creation time.
         * @returns {Promise<Array>} A promise that resolves to an array of idea task objects.
         * @throws {Error} If Firestore is not initialized or loading fails.
         */
        async function loadIdeaTasksFromFirestore() {
            // Check if Firestore is initialized
            if (!db || !hustleIdeaBoxCollection) { console.error("Firestore 'hustle_ideaBoxTasks' collection not initialized when loading ideas."); return []; }
            console.log("Loading idea tasks from Firestore...");
            const ideaTasks = [];
            try {
                // Query the collection, ordering by 'createdAt' descending
                const querySnapshot = await hustleIdeaBoxCollection.orderBy("createdAt", "desc").get();
                // Extract data from each document
                querySnapshot.forEach((doc) => {
                    ideaTasks.push({ id: doc.id, ...doc.data() }); // Include the document ID
                });
                console.log(`Loaded ${ideaTasks.length} idea tasks.`);
                return ideaTasks;
            } catch (error) {
                // Log detailed error information if loading fails
                console.error("❌❌❌ Error getting idea tasks:", error);
                console.error("Error Code:", error.code);
                console.error("Error Message:", error.message);
                // Show appropriate user alerts
                if (error.code === 'unavailable') {
                    alert("Could not connect to Firestore to load ideas. Please check your internet connection.");
                } else {
                    alert("Error loading ideas. Check console for details.");
                }
                throw error; // Re-throw the error
            }
        }

        /**
         * Adds a new task to the 'hustle_ideaBoxTasks' collection.
         * @param {string} taskText - The text content of the idea task.
         * @returns {Promise<string>} A promise that resolves to the new document's ID.
         * @throws {Error} If Firestore is not initialized or adding fails.
         */
        async function addIdeaTaskToFirestore(taskText) {
            console.log("DEBUG: Inside addIdeaTaskToFirestore, text:", taskText);
            // Check Firestore initialization
            if (!db) { console.error("DEBUG: Firestore DB object is not available in addIdeaTaskToFirestore."); throw new Error("Database not initialized."); }
            if (!hustleIdeaBoxCollection) { console.error("DEBUG: Firestore 'hustle_ideaBoxTasks' collection reference is not available."); throw new Error("Database collection 'hustle_ideaBoxTasks' could not be referenced."); }
            console.log("DEBUG: hustleIdeaBoxCollection reference is valid. Type:", typeof hustleIdeaBoxCollection, " Path:", hustleIdeaBoxCollection.path);

            console.log("DEBUG: Attempting Firestore add operation...");
            // Data to add, including a server timestamp for creation time
            const dataToAdd = {
                text: taskText,
                createdAt: firebase.firestore.FieldValue.serverTimestamp()
            };
            console.log("DEBUG: Data to add:", dataToAdd);

            try {
                // Add the document to the collection
                const docRef = await hustleIdeaBoxCollection.add(dataToAdd);
                console.log("DEBUG: Firestore add operation successful (inside try). Document ID: ", docRef.id);
                return docRef.id; // Return the new document ID
            } catch (error) {
                // Log detailed error information if adding fails
                console.error("DEBUG: Error during Firestore add operation (inside catch): ", error);
                console.error("DEBUG: Error Code:", error.code);
                console.error("DEBUG: Error Message:", error.message);
                // Show appropriate user alerts based on error code
                if (error.code === 'permission-denied') {
                    alert(`Error saving idea task: Permission denied. Check Firestore rules for hustle_ideaBoxTasks collection.`);
                } else {
                    alert(`Error saving idea task: ${error.message} (Code: ${error.code}). Check console logs.`);
                }
                throw error; // Re-throw the error
            }
        }

        /**
         * Deletes a task from the 'hustle_ideaBoxTasks' collection.
         * @param {string} taskId - The ID of the document to delete.
         * @throws {Error} If Firestore is not initialized or deleting fails.
         */
        async function deleteIdeaTaskFromFirestore(taskId) {
            // Check Firestore initialization
            if (!db || !hustleIdeaBoxCollection) { console.error("Firestore 'hustle_ideaBoxTasks' collection not initialized."); throw new Error("Database not initialized for Idea Box."); }
            console.log("DEBUG: Attempting to delete idea task with ID:", taskId);
            try {
                // Delete the document with the specified ID
                await hustleIdeaBoxCollection.doc(taskId).delete();
                console.log("DEBUG: Idea task deleted successfully from Firestore: ", taskId);
            } catch (error) {
                // Log detailed error information if deleting fails
                console.error("DEBUG: Error deleting idea task from Firestore: ", error);
                 // Show specific alert for permission errors
                 if (error.code === 'permission-denied') {
                     alert(`Error deleting idea task: Permission denied. Check Firestore rules allow 'delete' on hustle_ideaBoxTasks.`);
                 } else {
                     alert(`Error deleting idea task: ${error.message}. Check console.`);
                 }
                throw error; // Re-throw the error
            }
        }


        // --- Core Application Functions ---

        // Updates the time display element with the current formatted date and time
        function updateTimeDisplay() {
            if (timeDateDisplay) {
                timeDateDisplay.textContent = formatLiveDateTime(BOSTON_TIMEZONE);
            }
        }

        // Clears all task elements from the Kanban board columns
        function clearBoard() {
            columns.forEach(column => {
                const tc = column.querySelector('.tasks-container');
                if (tc) tc.innerHTML = ''; // Remove all child elements
            });
        }

        // Creates the inner HTML content for a task card (text, time, completion date)
        function createTaskDisplayContent(taskData) {
            const displayWrapper = document.createElement('div');
            displayWrapper.classList.add('task-content-display');

            // Add task text
            const textNode = document.createTextNode(taskData.text || 'No description');
            displayWrapper.appendChild(textNode);

            // Add start/end time and duration if available
            if (taskData.startTime && taskData.endTime) {
                const timeInfoSpan = document.createElement('span');
                timeInfoSpan.classList.add('task-time-info');
                const duration = calculateDuration(taskData.startTime, taskData.endTime);
                const formattedStart = formatTimeTo12Hour(taskData.startTime);
                const formattedEnd = formatTimeTo12Hour(taskData.endTime);
                timeInfoSpan.innerHTML = `${formattedStart} - ${formattedEnd}` + (duration ? ` <span class="duration">(${duration})</span>` : '');
                displayWrapper.appendChild(timeInfoSpan);
            }

            // Add completion date if available
            if (taskData.completionDate) {
                const dateSpan = document.createElement('span');
                dateSpan.classList.add('task-completion-date');
                dateSpan.textContent = `Completed: ${formatDisplayDate(taskData.completionDate)}`;
                displayWrapper.appendChild(dateSpan);
            }
            return displayWrapper;
        }

        // Creates a Kanban task element (div) from task data
        function createTaskElement(taskData, columnId) {
            // Generate a unique ID for the element if not provided (e.g., from Firestore)
            const taskId = taskData.firestoreId || `task-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
            const { text, startTime, endTime, completionDate } = taskData;

            // Create the main task div
            const task = document.createElement('div');
            task.classList.add('kanban-task');
            task.setAttribute('draggable', 'true'); // Make it draggable
            task.id = taskId;

            // Store task data in dataset attributes for easy access
            task.dataset.type = 'kanban-task';
            task.dataset.text = text || '';
            if (startTime) task.dataset.startTime = startTime; // Only set if startTime is not null/empty
            if (endTime) task.dataset.endTime = endTime;       // Only set if endTime is not null/empty
            if (completionDate) task.dataset.completionDate = completionDate;

            // Create and append the display content (text, time, etc.)
            const displayContent = createTaskDisplayContent(taskData);
            task.appendChild(displayContent);

            // Add progress bar elements if the task is in the 'inprogress' column and has times
            if (columnId === 'inprogress' && startTime && endTime) {
                task.appendChild(createProgressElements());
            }

            // Create and append the delete button
            const deleteBtn = document.createElement('button');
            deleteBtn.classList.add('delete-task-btn');
            deleteBtn.innerHTML = '&times;'; // Use '×' symbol
            deleteBtn.setAttribute('aria-label', 'Delete task');
            // Add click handler for deletion
            deleteBtn.onclick = async (event) => {
                event.stopPropagation(); // Prevent triggering edit mode on button click
                if (confirm(`Delete task: "${task.dataset.text}"?`)) {
                    task.remove(); // Remove element immediately from UI
                    await saveCurrentBoardState(); // Save the updated board state to Firestore
                }
            };
            task.appendChild(deleteBtn);

            // Add event listeners for drag-and-drop and double-click editing
            task.addEventListener('dragstart', handleDragStart);
            task.addEventListener('dragend', handleDragEnd);
            task.addEventListener('dblclick', (event) => {
                // Don't enter edit mode if the delete button was clicked
                if (event.target === deleteBtn || deleteBtn.contains(event.target)) return;
                enterEditMode(task);
            });

            return task;
        }

        // Creates the HTML elements for the progress bar and remaining time display
        function createProgressElements() {
            const container = document.createElement('div');
            container.classList.add('task-progress-container');

            const progressBar = document.createElement('div');
            progressBar.classList.add('progress-bar');
            const progressBarFill = document.createElement('div');
            progressBarFill.classList.add('progress-bar-fill');
            progressBar.appendChild(progressBarFill);

            const remainingTimeSpan = document.createElement('span');
            remainingTimeSpan.classList.add('remaining-time');
            remainingTimeSpan.textContent = 'Calculating...'; // Initial text

            container.appendChild(progressBar);
            container.appendChild(remainingTimeSpan);
            return container;
        }

        // --- Idea Box Functions ---

        // Creates an Idea Box task element (div) from idea task data
        function createIdeaTaskElement(ideaTaskData) {
            const { id, text } = ideaTaskData; // Destructure ID and text from data

            // Create the main task div
            const task = document.createElement('div');
            task.classList.add('idea-task');
            task.setAttribute('draggable', 'true'); // Make it draggable
            task.id = `idea-${id}`; // Use Firestore ID for the element ID
            task.dataset.id = id; // Store Firestore ID in dataset
            task.dataset.text = text;
            task.dataset.type = 'idea-task'; // Mark type for drag/drop logic

            // Add task text
            const textSpan = document.createElement('span');
            textSpan.textContent = text;
            task.appendChild(textSpan);

            // Create and append the delete button
            const deleteBtn = document.createElement('button');
            deleteBtn.classList.add('delete-idea-task-btn');
            deleteBtn.innerHTML = '&times;';
            deleteBtn.setAttribute('aria-label', 'Delete idea task');

            // Add click handler for deletion
            deleteBtn.addEventListener('click', async (event) => {
                event.stopPropagation();
                // Retrieve the ID directly from the element's dataset when clicked
                const taskIdToDelete = task.dataset.id;
                console.log(`DEBUG: Delete button clicked for idea ID: ${taskIdToDelete}, Text: "${task.dataset.text}"`);

                if (confirm(`Are you sure you want to delete idea: "${task.dataset.text}"?`)) {
                    deleteBtn.disabled = true; // Disable button during deletion
                    try {
                        console.log(`DEBUG: Calling deleteIdeaTaskFromFirestore for ID: ${taskIdToDelete}`);
                        await deleteIdeaTaskFromFirestore(taskIdToDelete); // Call Firestore delete
                        console.log(`DEBUG: Firestore delete successful for ID: ${taskIdToDelete}. Removing element.`);
                        task.remove(); // Remove element from UI on success
                    } catch (error) {
                        deleteBtn.disabled = false; // Re-enable button on error
                        console.error("DEBUG: Failed to delete idea task (error caught in click handler):", error);
                        // Alert is handled within deleteIdeaTaskFromFirestore
                    }
                } else {
                    console.log("DEBUG: Delete confirmation cancelled.");
                }
            });
            task.appendChild(deleteBtn);

            // Add drag-and-drop listeners
            task.addEventListener('dragstart', handleDragStart);
            task.addEventListener('dragend', handleDragEnd);
            return task;
        }

        // Loads and displays tasks from the Idea Box collection in the UI
        async function displayIdeaTasks() {
            if (!ideaTaskList) return; // Ensure the list element exists
            ideaTaskList.innerHTML = '<p class="text-slate-400 text-center italic">Loading ideas...</p>'; // Show loading indicator
            try {
                const ideaTasks = await loadIdeaTasksFromFirestore(); // Fetch tasks
                ideaTaskList.innerHTML = ''; // Clear loading/previous list

                if (ideaTasks.length === 0) {
                    // Show message if no ideas exist
                    ideaTaskList.innerHTML = '<p class="text-slate-400 text-center italic">No ideas captured yet. Add some!</p>';
                } else {
                    // Create and append elements for each idea task
                    ideaTasks.forEach(taskData => {
                        const taskElement = createIdeaTaskElement(taskData);
                        ideaTaskList.appendChild(taskElement);
                    });
                }
            } catch (error) {
                 console.error("Error displaying idea tasks:", error);
                 // Show error message in the UI if loading failed
                 if (ideaTaskList.innerHTML.includes('Loading')) { // Avoid duplicate error messages
                     ideaTaskList.innerHTML = '<p class="text-red-400 text-center italic">Error loading ideas. Please check connection/console.</p>';
                 }
            }
        }

        // Handles adding a new task to the Idea Box
        async function addIdeaTask() {
            console.log("DEBUG: addIdeaTask called");
            if (!ideaTaskInput || !addIdeaTaskBtn) { console.error("DEBUG: Idea task input or button not found."); return; }
            const taskText = ideaTaskInput.value.trim(); // Get and trim input value
            if (taskText === '') { // Validate input
                alert('Please enter an idea description.');
                ideaTaskInput.focus();
                return;
            }

            console.log("DEBUG: Disabling button, text:", taskText);
            addIdeaTaskBtn.disabled = true; addIdeaTaskBtn.textContent = 'Adding...'; // Provide user feedback

            try {
                console.log("DEBUG: Calling addIdeaTaskToFirestore...");
                const newId = await addIdeaTaskToFirestore(taskText); // Add to Firestore
                console.log("DEBUG: Back from addIdeaTaskToFirestore. ID:", newId);

                // Create data object including the new ID received from Firestore
                const newTaskData = { id: newId, text: taskText, createdAt: new Date() }; // Use actual ID
                const newTaskElement = createIdeaTaskElement(newTaskData); // Create UI element

                // Update UI
                const placeholder = ideaTaskList.querySelector('p'); // Find placeholder text
                if (placeholder) placeholder.remove(); // Remove placeholder if it exists
                ideaTaskList.prepend(newTaskElement); // Add new task to the top of the list
                ideaTaskInput.value = ''; // Clear input field ONLY on success
                console.log("DEBUG: Successfully added idea to UI:", taskText);

            } catch (error) {
                // Error handling (alert is shown within addIdeaTaskToFirestore)
                console.error("DEBUG: Error caught in addIdeaTask's catch block:", error);
            } finally {
                // Always re-enable the button and reset its text
                console.log("DEBUG: Executing finally block in addIdeaTask");
                addIdeaTaskBtn.disabled = false;
                addIdeaTaskBtn.textContent = 'Add Idea';
                ideaTaskInput.focus(); // Set focus back to input
            }
        }


        // --- Edit Mode Functions (Daily Tasks) ---

        // Switches a Kanban task element into edit mode
        function enterEditMode(taskElement) {
            if (taskElement.classList.contains('editing')) return; // Already in edit mode

            taskElement.classList.add('editing');
            taskElement.setAttribute('draggable', 'false'); // Disable dragging while editing

            // Hide the normal display content and progress bar
            const displayContent = taskElement.querySelector('.task-content-display');
            if (displayContent) displayContent.style.display = 'none';
            const progressContainer = taskElement.querySelector('.task-progress-container');
            if (progressContainer) progressContainer.style.display = 'none';

            // Create the edit form elements
            const editForm = document.createElement('div');
            editForm.classList.add('task-edit-form');

            const textInput = document.createElement('input');
            textInput.type = 'text';
            textInput.value = taskElement.dataset.text || '';
            textInput.placeholder = 'Task description';

            const timeInputsDiv = document.createElement('div');
            timeInputsDiv.classList.add('edit-time-inputs');
            const startTimeDiv = document.createElement('div');
            const startTimeInput = document.createElement('input');
            startTimeInput.type = 'time';
            startTimeInput.value = taskElement.dataset.startTime || ''; // Pre-fill with existing or empty
            startTimeDiv.appendChild(startTimeInput);
            const endTimeDiv = document.createElement('div');
            const endTimeInput = document.createElement('input');
            endTimeInput.type = 'time';
            endTimeInput.value = taskElement.dataset.endTime || ''; // Pre-fill with existing or empty
            endTimeDiv.appendChild(endTimeInput);
            timeInputsDiv.appendChild(startTimeDiv);
            timeInputsDiv.appendChild(endTimeDiv);

            const buttonsDiv = document.createElement('div');
            buttonsDiv.classList.add('edit-buttons');
            const saveBtn = document.createElement('button');
            saveBtn.textContent = 'Save';
            saveBtn.classList.add('edit-save-btn');
            saveBtn.onclick = () => saveEdit(taskElement, textInput, startTimeInput, endTimeInput); // Pass elements to save function
            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = 'Cancel';
            cancelBtn.classList.add('edit-cancel-btn');
            cancelBtn.onclick = () => cancelEdit(taskElement);
            buttonsDiv.appendChild(saveBtn);
            buttonsDiv.appendChild(cancelBtn);

            // Append form elements to the task element
            editForm.appendChild(textInput);
            editForm.appendChild(timeInputsDiv);
            editForm.appendChild(buttonsDiv);
            taskElement.appendChild(editForm);

            textInput.focus(); // Focus the text input
        }

        // Exits edit mode for a Kanban task element
        function exitEditMode(taskElement) {
            const editForm = taskElement.querySelector('.task-edit-form');
            if (editForm) editForm.remove(); // Remove the edit form

            // Restore visibility of normal display content and progress bar
            const displayContent = taskElement.querySelector('.task-content-display');
            if (displayContent) displayContent.style.display = '';
            const progressContainer = taskElement.querySelector('.task-progress-container');
            if (progressContainer) progressContainer.style.display = 'flex'; // Use flex for progress bar layout

            taskElement.classList.remove('editing');
            taskElement.setAttribute('draggable', 'true'); // Re-enable dragging
        }

        // Saves the edited task data and updates the UI and Firestore
        async function saveEdit(taskElement, textInput, startTimeInput, endTimeInput) {
            let newText = textInput.value.trim();
            let newStartTime = startTimeInput.value;
            let newEndTime = endTimeInput.value;

            // --- Input Validation ---
            if (newText === '') {
                alert('Task description cannot be empty.');
                textInput.focus();
                return;
            }

            // Time validation for edit:
            if (newStartTime || newEndTime) { // If either time field has a value
                if (!newStartTime) {
                    alert('Please enter a start time if providing an end time, or leave both empty.');
                    startTimeInput.focus();
                    return;
                }
                if (!newEndTime) {
                    alert('Please enter an end time if providing a start time, or leave both empty.');
                    endTimeInput.focus();
                    return;
                }
                if (newStartTime >= newEndTime) {
                    alert('End time must be after start time.');
                    endTimeInput.focus();
                    return;
                }
                // Times are valid and provided
                taskElement.dataset.startTime = newStartTime;
                taskElement.dataset.endTime = newEndTime;
            } else {
                // Both newStartTime and newEndTime are empty, user wants to remove time
                delete taskElement.dataset.startTime;
                delete taskElement.dataset.endTime;
                // Ensure newStartTime and newEndTime are null for updatedDisplayData
                newStartTime = null;
                newEndTime = null;
            }
            // --- End Validation ---

            // Update the task element's dataset text
            taskElement.dataset.text = newText;
            const completionDate = taskElement.dataset.completionDate || null;

            // Update the display content within the task element
            const displayContent = taskElement.querySelector('.task-content-display');
            if (displayContent) {
                while (displayContent.firstChild) {
                    displayContent.removeChild(displayContent.firstChild);
                }
                const updatedDisplayData = { text: newText, startTime: newStartTime, endTime: newEndTime, completionDate: completionDate };
                const newDisplayNodes = createTaskDisplayContent(updatedDisplayData); // This returns a div
                while (newDisplayNodes.firstChild) { // Append children of the newDisplay div
                    displayContent.appendChild(newDisplayNodes.firstChild);
                }
            }

            // Handle progress bar for tasks in 'inprogress' column
            if (taskElement.closest('#inprogress')) {
                const progressContainer = taskElement.querySelector('.task-progress-container');
                if (newStartTime && newEndTime) { // Times are set
                    if (!progressContainer) { // Add progress bar if it doesn't exist
                        const newProgressElements = createProgressElements();
                        // Append before delete button if possible, otherwise just append
                        const deleteBtn = taskElement.querySelector('.delete-task-btn');
                        if (deleteBtn) {
                            taskElement.insertBefore(newProgressElements, deleteBtn);
                        } else {
                            taskElement.appendChild(newProgressElements);
                        }
                    }
                    updateSingleTaskTimer(taskElement); // Update timer immediately
                } else { // Times were removed
                    if (progressContainer) {
                        progressContainer.remove(); // Remove progress bar
                    }
                }
            }

            exitEditMode(taskElement); // Exit the editing UI
            await saveCurrentBoardState(); // Save the entire board state to Firestore
            console.log("Task edited and saved:", taskElement.id);
        }


        // Cancels the edit operation and restores the task element's original state
        function cancelEdit(taskElement) {
            exitEditMode(taskElement);
            console.log("Task edit cancelled:", taskElement.id);
        }

        // --- Daily Task Board Functions ---

        /**
         * Loads and displays tasks for a specific date on the Kanban board.
         * @param {string} dateString - The date in YYYY-MM-DD format.
         */
        async function displayTasksForDate(dateString) {
            // Check Firestore initialization
            if (!db) {
                selectedDateDisplay.textContent = "Database not connected.";
                return;
            }
            currentSelectedDate = dateString; // Update the global state
            const formattedDate = formatDisplayDate(dateString); // Format for display
            selectedDateDisplay.textContent = `Loading tasks for ${formattedDate}...`; // Update UI
            if (dateSelector) dateSelector.value = dateString; // Sync date picker input
            clearBoard(); // Clear existing tasks from the board

            try {
                // Load tasks using the enhanced loadTasksFromFirestore function
                const tasksForDay = await loadTasksFromFirestore(dateString);

                // Update display message only on successful load
                selectedDateDisplay.textContent = `Showing tasks for: ${formattedDate}`;

                // Populate Kanban columns with loaded tasks
                Object.keys(tasksForDay).forEach(columnId => {
                    const columnElement = document.getElementById(columnId);
                    const tasksContainer = columnElement?.querySelector('.tasks-container');
                    if (tasksContainer) {
                        // tasksContainer.innerHTML = ''; // Optional: Ensure container is empty
                        tasksForDay[columnId].forEach(taskData => {
                            const taskElement = createTaskElement(taskData, columnId);
                            tasksContainer.appendChild(taskElement);
                        });
                    } else {
                        console.warn(`Tasks container not found in column "${columnId}".`);
                    }
                });

                checkAndMoveTasks(); // Check if tasks need to be moved based on current time
                updateInProgressTimers(); // Initialize/update progress timers

            } catch (error) {
                // Error is logged in detail within loadTasksFromFirestore
                console.error("Error caught by displayTasksForDate:", error);
                // Update display to indicate failure (alert was already shown)
                selectedDateDisplay.textContent = `Showing tasks for: ${formattedDate} (Load Failed)`;
                // Avoid running checks/timers if the load failed
            }
        }

        /**
         * Gathers the current state of all tasks on the board and saves it to Firestore
         * for the currently selected date.
         */
        async function saveCurrentBoardState() {
             // Check Firestore initialization
             if (!db || !hustleTasksCollection) { console.error("Firestore 'hustle_tasks' collection not initialized."); return; }
             // Check if a date is selected
             if (!currentSelectedDate) { console.log("No date selected, cannot save daily state."); return; }

             // Prepare the data structure to save
             const tasksForCurrentDate = { todo: [], inprogress: [], done: [] };

             // Iterate through each column
             columns.forEach(column => {
                 const columnId = column.id;
                 const tasksContainer = column.querySelector('.tasks-container');
                 // Check if the column ID is valid and the container exists
                 if (tasksForCurrentDate.hasOwnProperty(columnId) && tasksContainer) {
                     // Iterate through each task element in the container
                     tasksContainer.querySelectorAll('.kanban-task').forEach(task => {
                         // Skip tasks currently being edited
                         if (task.classList.contains('editing')) {
                             console.warn("Skipping save for task in edit mode:", task.id);
                             return;
                         }
                         // Extract task data from dataset attributes
                         const taskData = {
                             text: task.dataset.text || '',
                             startTime: task.dataset.startTime || null, // Will be null if attribute not set
                             endTime: task.dataset.endTime || null,     // Will be null if attribute not set
                             // Retrieve completion date carefully, ensuring 'null' string isn't saved
                             completionDate: task.dataset.completionDate && task.dataset.completionDate !== 'null' ? task.dataset.completionDate : null
                         };
                         // Only save tasks that have text content
                         if (taskData.text) {
                             tasksForCurrentDate[columnId].push(taskData);
                         } else {
                             console.warn("Skipping saving daily task with no text:", task.id);
                         }
                     });
                 } else if (!tasksContainer) {
                     console.warn(`Tasks container not found in column "${columnId}" during save.`);
                 }
             });

             // Call the function to save the structured data to Firestore
             await saveTasksToFirestore(currentSelectedDate, tasksForCurrentDate);
         }

        /**
         * Handles adding a new daily task from the form to the 'To Do' column.
         */
        async function addTask() {
            // Check Firestore initialization
            if (!db || !hustleTasksCollection) { alert("Database not connected. Cannot add task."); return; }

            // Get references to form elements
            const taskInput = document.getElementById('new-task-input');
            const startTimeInput = document.getElementById('new-task-start-time');
            const endTimeInput = document.getElementById('new-task-end-time');
            const todoColumn = document.getElementById('todo');
            const todoTasksContainer = todoColumn?.querySelector('.tasks-container');

            // Ensure all elements are found
            if (!taskInput || !startTimeInput || !endTimeInput || !todoTasksContainer) {
                console.error("Error: Daily task form/column elements not found.");
                alert("Error: Could not find necessary form elements.");
                return;
            }

            // Get form input values
            const taskText = taskInput.value.trim();
            let startTime = startTimeInput.value; // Use let to potentially set to null
            let endTime = endTimeInput.value;     // Use let to potentially set to null

            if (taskText === '') {
                alert('Please enter a task description.');
                taskInput.focus();
                return;
            }

            if (!currentSelectedDate) {
                alert('Cannot add task: No date selected. Please select a date or refresh.');
                return;
            }

            // Time validation logic
            if (startTime || endTime) { // If either time field has a value
                if (!startTime) {
                    alert('Please enter a start time if providing an end time.');
                    startTimeInput.focus();
                    return;
                }
                if (!endTime) {
                    alert('Please enter an end time if providing a start time.');
                    endTimeInput.focus();
                    return;
                }
                if (startTime >= endTime) {
                    alert('End time must be after start time.');
                    endTimeInput.focus();
                    return;
                }
                // Times are valid and provided
            } else {
                // Both startTime and endTime are empty, so set them to null for data consistency
                startTime = null;
                endTime = null;
            }

            // Create task data object
            const newTaskData = { text: taskText, startTime: startTime, endTime: endTime, completionDate: null };
            // Create the task element for the UI
            const newTaskElement = createTaskElement(newTaskData, 'todo');

            if (newTaskElement) {
                // Add the new task element to the 'To Do' column
                todoTasksContainer.appendChild(newTaskElement);
            } else {
                console.error("Error creating daily task element.");
                alert("Error: Could not create the task visually.");
                return;
            }

            // Clear the form fields
            taskInput.value = '';
            startTimeInput.value = ''; // Clear time inputs regardless
            endTimeInput.value = '';   // Clear time inputs regardless

            // Save the updated board state to Firestore
            await saveCurrentBoardState();
            console.log(`Daily task added locally for "${taskText}", saving board state.`);

            checkAndMoveTasks(); // Check if the new task should be moved immediately (if times were provided)
        }



        // --- Drag and Drop Event Handlers ---

        // Called when dragging of a task starts
        function handleDragStart(event) {
            // Prevent dragging if the task is being edited
            if (event.target.classList.contains('kanban-task') && event.target.classList.contains('editing')) {
                event.preventDefault();
                return;
            }
            draggedElement = event.target; // Store the element being dragged
            draggedElementType = event.target.dataset.type; // Store its type
            event.dataTransfer.setData('text/plain', event.target.id); // Set data for the drag operation
            event.dataTransfer.effectAllowed = "move"; // Indicate that moving is allowed
            // Add dragging class slightly later for visual feedback
            setTimeout(() => {
                if (draggedElement) draggedElement.classList.add('dragging');
            }, 0);
            console.log(`Drag Start: ${draggedElementType} - ${draggedElement.id}`);
        }

        // Called when dragging of a task ends (successfully or cancelled)
        function handleDragEnd() {
            if (draggedElement) {
                draggedElement.classList.remove('dragging'); // Remove dragging style
                console.log(`Drag End: ${draggedElementType} - ${draggedElement.id}`);
            }
            // Clear state variables
            draggedElement = null;
            draggedElementType = null;
            // Remove drag-over styling from all columns
            columns.forEach(col => col.classList.remove('drag-over'));
        }

        // Called frequently as an element is dragged over a potential drop target
        function handleDragOver(event) {
            event.preventDefault(); // Necessary to allow dropping
            const targetColumn = event.target.closest('.kanban-column');
            const targetTask = event.target.closest('.kanban-task, .idea-task');

            // Prevent dropping onto a task that is being edited
            if (targetTask && targetTask.classList.contains('editing')) {
                event.dataTransfer.dropEffect = "none"; // Indicate dropping is not allowed
                return;
            }
            // Prevent dropping idea tasks onto 'In Progress' or 'Done' columns
            if (draggedElementType === 'idea-task' && targetColumn && (targetColumn.id === 'inprogress' || targetColumn.id === 'done')) {
                event.dataTransfer.dropEffect = "none";
                return;
            }

            event.dataTransfer.dropEffect = "move"; // Indicate dropping is allowed

            // Add visual feedback to the column being dragged over
            if (targetColumn && !targetColumn.classList.contains('drag-over')) {
                columns.forEach(col => col.classList.remove('drag-over')); // Remove from others
                targetColumn.classList.add('drag-over'); // Add to current target
            }
        }

        // Called when a dragged element leaves a potential drop target
        function handleDragLeave(event) {
            const targetColumn = event.target.closest('.kanban-column');
            // Remove drag-over style if the mouse leaves the column area
            if (targetColumn && !targetColumn.contains(event.relatedTarget)) {
                targetColumn.classList.remove('drag-over');
            }
        }

        // Called when a dragged element is dropped onto a valid drop target
        async function handleDrop(event) {
            event.preventDefault(); // Prevent default browser behavior
            const targetColumn = event.target.closest('.kanban-column');
            const targetTasksContainer = targetColumn?.querySelector('.tasks-container');
            const targetElement = event.target.closest('.kanban-task, .idea-task'); // Element being dropped onto (if any)

            targetColumn?.classList.remove('drag-over'); // Remove visual feedback

            // --- Validation checks ---
            if (!targetColumn || !targetTasksContainer || !draggedElement || !draggedElementType) {
                console.warn("Drop cancelled: Invalid target or no dragged element."); return;
            }
            if (targetElement && targetElement.classList.contains('editing')) {
                console.warn("Drop cancelled: Target element is being edited."); return;
            }
            // Prevent invalid drops (idea task to wrong column, dropping onto self)
            if (draggedElementType === 'idea-task' && (targetColumn.id === 'inprogress' || targetColumn.id === 'done')) {
                 console.warn("Drop cancelled: Idea tasks can only be dropped onto 'To Do'."); return;
            }
            if (draggedElement === targetElement) {
                 console.warn("Drop cancelled: Dropped onto self."); return;
            }
            // --- End Validation ---

            console.log(`Drop detected: ${draggedElementType} onto ${targetColumn.id}`);

            // --- Handle different drop scenarios ---

            // Scenario 1: Dropping an Idea Task onto the 'To Do' column
            if (draggedElementType === 'idea-task' && targetColumn.id === 'todo') {
                // Store idea data and show the time prompt modal
                ideaTaskToSchedule = { id: draggedElement.dataset.id, text: draggedElement.dataset.text };
                showTimePrompt(ideaTaskToSchedule.text);
                // The original idea task element remains in the Idea Box until scheduled via modal
            }
            // Scenario 2: Dropping a Kanban Task (moving between columns or reordering)
            else if (draggedElementType === 'kanban-task') {
                const previousColumn = draggedElement.parentElement.closest('.kanban-column');
                let completionDate = draggedElement.dataset.completionDate || null;

                // --- Update task state based on target column ---

                // Remove progress bar if moving out of 'In Progress'
                if (previousColumn?.id === 'inprogress' && targetColumn.id !== 'inprogress') {
                    const progressContainer = draggedElement.querySelector('.task-progress-container');
                    if (progressContainer) progressContainer.remove();
                }

                // Clear completion date if moving out of 'Done'
                if (targetColumn.id !== 'done') {
                    const existingDateSpan = draggedElement.querySelector('.task-completion-date');
                    if (existingDateSpan) existingDateSpan.remove();
                    delete draggedElement.dataset.completionDate; // Remove from dataset
                    completionDate = null;
                }

                // Handle moving into 'Done'
                if (targetColumn.id === 'done') {
                    // Set completion date if not already set
                    if (!completionDate) {
                        completionDate = getCurrentDateString(BOSTON_TIMEZONE);
                        draggedElement.dataset.completionDate = completionDate;
                    }
                    // Update or add the completion date display
                    const existingDateSpan = draggedElement.querySelector('.task-completion-date');
                    if (existingDateSpan) existingDateSpan.remove(); // Remove old one first
                    const dateSpan = document.createElement('span');
                    dateSpan.classList.add('task-completion-date');
                    dateSpan.textContent = `Completed: ${formatDisplayDate(completionDate)}`;
                    // Append after time info or at the end of display content
                    const timeInfo = draggedElement.querySelector('.task-time-info');
                    const displayContent = draggedElement.querySelector('.task-content-display');
                    if (timeInfo) {
                        timeInfo.insertAdjacentElement('afterend', dateSpan);
                    } else if (displayContent) {
                        displayContent.appendChild(dateSpan);
                    }
                    // Trigger confetti if moving into 'Done' from another column
                    if (previousColumn && previousColumn.id !== 'done' && myConfetti) {
                        triggerConfetti();
                    }
                }

                // Handle moving into 'In Progress'
                if (targetColumn.id === 'inprogress' && previousColumn?.id !== 'inprogress') {
                    // Add progress elements if the task has start/end times
                    if (draggedElement.dataset.startTime && draggedElement.dataset.endTime) {
                        if (!draggedElement.querySelector('.task-progress-container')) {
                            draggedElement.appendChild(createProgressElements());
                        }
                        updateSingleTaskTimer(draggedElement); // Update timer immediately
                    }
                }

                // --- Move the element in the DOM ---
                // Insert before the target element if dropped onto another task, otherwise append to the end
                if (targetElement && targetTasksContainer.contains(targetElement)) {
                    targetTasksContainer.insertBefore(draggedElement, targetElement);
                } else {
                    targetTasksContainer.appendChild(draggedElement);
                }

                // Save the new board state and update timers
                await saveCurrentBoardState();
                updateInProgressTimers();
            }
        }


        // --- Time Prompt Modal Functions ---

        // Shows the modal to set start/end times for a scheduled idea task
        function showTimePrompt(taskText) {
            if (!timePromptModal || !modalTaskText || !modalStartTimeInput || !modalEndTimeInput) return;
            modalTaskText.textContent = `Scheduling: "${taskText}"`; // Display task text
            modalStartTimeInput.value = ''; // Clear inputs
            modalEndTimeInput.value = '';
            timePromptModal.classList.add('active'); // Make modal visible
            modalStartTimeInput.focus(); // Focus the start time input
        }

        // Hides the time prompt modal and resets state
        function hideTimePrompt() {
            if (!timePromptModal) return;
            timePromptModal.classList.remove('active'); // Hide modal
            ideaTaskToSchedule = null; // Clear the task data being scheduled
            modalStartTimeInput.value = '';
            modalEndTimeInput.value = '';
        }

        // Handles saving the scheduled task from the modal
        async function handleModalSave() {
            // Ensure data and elements are available
            if (!ideaTaskToSchedule || !modalStartTimeInput || !modalEndTimeInput) {
                console.error("Cannot save modal: Missing task data or input elements.");
                hideTimePrompt(); return;
            }
            // Get and validate times
            const startTime = modalStartTimeInput.value;
            const endTime = modalEndTimeInput.value;
            if (!startTime) { alert('Please enter a start time.'); modalStartTimeInput.focus(); return; }
            if (!endTime) { alert('Please enter an end time.'); modalEndTimeInput.focus(); return; }
            if (startTime >= endTime) { alert('End time must be after start time.'); modalEndTimeInput.focus(); return; }
            if (!currentSelectedDate) { alert('Cannot schedule task: No date selected.'); hideTimePrompt(); return; }

            // Create data for the new Kanban task
            const newTaskData = {
                text: ideaTaskToSchedule.text,
                startTime: startTime,
                endTime: endTime,
                completionDate: null
            };
            // Create the UI element
            const newTaskElement = createTaskElement(newTaskData, 'todo');
            const todoColumn = document.getElementById('todo');
            const todoTasksContainer = todoColumn?.querySelector('.tasks-container');

            if (newTaskElement && todoTasksContainer) {
                // Add the new task to the 'To Do' column
                todoTasksContainer.appendChild(newTaskElement);
                // Save the updated board state
                await saveCurrentBoardState();
                console.log(`Scheduled idea task "${newTaskData.text}" for ${currentSelectedDate}`);

                // --- Delete the original idea task from Firestore and UI ---
                try {
                    console.log(`DEBUG: Deleting original idea task (ID: ${ideaTaskToSchedule.id}) after scheduling.`);
                    await deleteIdeaTaskFromFirestore(ideaTaskToSchedule.id);
                    const originalIdeaElement = document.getElementById(`idea-${ideaTaskToSchedule.id}`);
                    if (originalIdeaElement) {
                        originalIdeaElement.remove();
                        console.log(`DEBUG: Removed original idea task element from UI.`);
                    } else {
                        console.warn(`DEBUG: Could not find original idea task element (ID: idea-${ideaTaskToSchedule.id}) to remove from UI.`);
                    }
                } catch (error) {
                    console.error(`Error deleting original idea task (ID: ${ideaTaskToSchedule.id}) after scheduling:`, error);
                    // Inform user, but the main scheduling likely succeeded
                    alert(`Task scheduled, but failed to remove the original from the Idea Box. Please remove it manually.`);
                }
                // --- End Deletion ---

                hideTimePrompt(); // Close the modal
            } else {
                console.error("Error creating or appending scheduled task element.");
                alert("Error adding scheduled task to the board.");
                hideTimePrompt();
            }
        }


        // --- Other Core Functions ---

        // Triggers a confetti burst effect
        function triggerConfetti() {
            if (!myConfetti) return; // Ensure confetti is initialized
            myConfetti({
                particleCount: 200, // Number of confetti particles
                spread: 100, // How wide the confetti spreads
                origin: { y: 0.6 }, // Starting position (0.6 means 60% down the screen)
                colors: ['#f97316', '#ef4444', '#facc15', '#ffffff', '#a855f7'] // Custom colors
            });
        }

        // Archives a completed task to the 'hustle_archive' collection
        async function archiveTaskToFirestore(taskData) {
            if (!db || !hustleArchiveCollection) { console.error("Firestore 'hustle_archive' collection not initialized."); return; }
            // Ensure task has necessary data for archiving
            if (!taskData.completionDate || !taskData.text) {
                console.warn("Skipping archive for task missing completion date or text:", taskData);
                return;
            }
            // Add an 'archivedAt' timestamp
            const archiveData = {
                ...taskData,
                archivedAt: firebase.firestore.FieldValue.serverTimestamp()
            };
            try {
                await hustleArchiveCollection.add(archiveData); // Add to archive collection
                console.log("Task archived to Firestore:", taskData.text);
            } catch (error) {
                console.error("Error archiving task to Firestore:", error);
                // Consider if user notification is needed here
            }
        }

        // Processes past dates, moves completed tasks to archive, and cleans up old documents
        async function runArchivingProcess() {
            if (!db || !hustleTasksCollection || !hustleArchiveCollection) {
                console.error("Firestore not initialized. Skipping archiving.");
                return false;
            }
            const todayDateStr = getCurrentDateString(BOSTON_TIMEZONE);
            let tasksArchived = false;
            console.log("Running archiving process...");

            try {
                // Query for documents in 'hustle_tasks' with IDs (dates) less than today's date
                const querySnapshot = await hustleTasksCollection.where(firebase.firestore.FieldPath.documentId(), "<", todayDateStr).get();

                if (querySnapshot.empty) {
                    console.log("No past dates found with tasks to archive.");
                    return false; // Nothing to do
                }

                const batch = db.batch(); // Use a batch for efficient updates/deletes
                const archivePromises = []; // To track individual archive additions

                querySnapshot.forEach(doc => {
                    const dateString = doc.id;
                    const tasksForDay = doc.data();
                    let dayWasModified = false; // Flag if changes are made to this day's doc

                    // Process 'done' tasks for this past date
                    if (tasksForDay.done && Array.isArray(tasksForDay.done) && tasksForDay.done.length > 0) {
                        const tasksToKeepInDone = []; // Tasks that might remain (e.g., if missing completion date)
                        const tasksToArchive = [];    // Tasks to move to the archive collection

                        tasksForDay.done.forEach(taskData => {
                            // Only archive tasks that have a completion date
                            if (taskData.completionDate) {
                                tasksToArchive.push(taskData);
                                tasksArchived = true;
                                dayWasModified = true;
                            } else {
                                // Keep tasks without a completion date in the 'done' list (shouldn't happen ideally)
                                tasksToKeepInDone.push(taskData);
                                console.warn(`Task in 'done' column for ${dateString} lacks completion date:`, taskData.text);
                            }
                        });

                        // If tasks were marked for archiving, update the original document
                        if (dayWasModified) {
                            // Add individual archive operations (these happen outside the batch)
                            tasksToArchive.forEach(taskData => {
                                archivePromises.push(archiveTaskToFirestore(taskData));
                            });
                            // Update the original date document in the batch to remove the archived tasks
                            const docRef = hustleTasksCollection.doc(dateString);
                            batch.update(docRef, { done: tasksToKeepInDone });
                            console.log(`Marked document ${dateString} for update in batch (removing archived tasks).`);
                        }
                    }
                    // Optional: Check if 'todo' and 'inprogress' are also empty after processing 'done'
                    // If all lists are empty, you could potentially delete the entire date document using batch.delete(docRef)
                    // Example:
                    // if (dayWasModified && tasksToKeepInDone.length === 0 && (!tasksForDay.todo || tasksForDay.todo.length === 0) && (!tasksForDay.inprogress || tasksForDay.inprogress.length === 0)) {
                    //     console.log(`Marking empty document ${dateString} for deletion in batch.`);
                    //     batch.delete(hustleTasksCollection.doc(dateString));
                    // }
                });

                // Commit all batched writes/updates/deletes
                await batch.commit();
                console.log("Batch update/delete committed successfully.");
                // Wait for all individual archive additions to settle
                await Promise.allSettled(archivePromises);
                console.log("Individual archive operations settled.");

            } catch (error) {
                console.error("Error during archiving process query or batch commit:", error);
                // Handle potential errors during the batch commit or query
            }
            console.log(`Archiving process finished. Tasks archived: ${tasksArchived}`);
            return tasksArchived;
        }

        // Generates the summary text for the previous day's completed tasks
        function generateSummaryText(tasks) {
            let taskSummary;
            if (!tasks || tasks.length === 0) {
                taskSummary = "Looks like there were no completed tasks logged for the previous day.";
            } else {
                const taskTexts = tasks.map(t => t.text || 'Unnamed Task');
                taskSummary = `Yesterday, you crushed ${tasks.length} task(s): `;
                // Format the list nicely
                if (taskTexts.length === 1) {
                    taskSummary += `<strong>${taskTexts[0]}</strong>.`;
                } else if (taskTexts.length === 2) {
                    taskSummary += `<strong>${taskTexts[0]}</strong> and <strong>${taskTexts[1]}</strong>.`;
                } else {
                    const lastTask = taskTexts.pop();
                    taskSummary += `<strong>${taskTexts.join('</strong>, <strong>')}</strong>, and <strong>${lastTask}</strong>.`;
                }
            }
            // Add a random motivational suffix
            if (motivationalSuffixes.length > 0) {
                currentSuffixIndex = (currentSuffixIndex + 1) % motivationalSuffixes.length;
                taskSummary += `<span class="motivation-suffix">${motivationalSuffixes[currentSuffixIndex]}</span>`;
            } else {
                taskSummary += `<span class="motivation-suffix">Keep up the great work!</span>`; // Fallback
            }
            return taskSummary;
        }

        // Fetches archived tasks for yesterday and displays the summary
        async function displayLatestSummary() {
            if (!db || !hustleArchiveCollection) { console.error("Firestore 'hustle_archive' collection not initialized."); dailySummaryDiv.classList.add('hidden'); return; }
            console.log("Fetching previous day's summary...");

            // Calculate yesterday's date string
            const today = new Date();
            const yesterday = new Date(today);
            yesterday.setDate(today.getDate() - 1);
            const yesterdayDateStr = new Intl.DateTimeFormat('en-CA', { year: 'numeric', month: '2-digit', day: '2-digit', timeZone: BOSTON_TIMEZONE }).format(yesterday);

            try {
                // Query the archive collection for tasks completed yesterday
                const querySnapshot = await hustleArchiveCollection.where("completionDate", "==", yesterdayDateStr).get();
                const tasksForYesterday = [];
                querySnapshot.forEach(doc => {
                    tasksForYesterday.push(doc.data());
                });

                // Generate and display the summary text
                summaryContentP.innerHTML = generateSummaryText(tasksForYesterday);
                const summaryTitle = dailySummaryDiv.querySelector('h3');
                if (summaryTitle) summaryTitle.textContent = `Daily Wins Recap for ${formatDisplayDate(yesterdayDateStr)}!`;
                dailySummaryDiv.classList.remove('hidden'); // Show the summary section
                console.log(`Displaying summary for ${yesterdayDateStr} with ${tasksForYesterday.length} tasks.`);
            } catch (error) {
                console.error("Error fetching archived tasks for summary:", error);
                summaryContentP.innerHTML = "Could not load previous day's summary.";
                const summaryTitle = dailySummaryDiv.querySelector('h3');
                if (summaryTitle) summaryTitle.textContent = `Daily Wins Recap`;
                dailySummaryDiv.classList.remove('hidden'); // Still show the section, but with error text
            }
        }

        // Checks tasks in 'To Do' column and moves them to 'In Progress' if their start time has passed
        async function checkAndMoveTasks() {
            if (!db) return; // Ensure DB is initialized
            const todayDateStr = getCurrentDateString(BOSTON_TIMEZONE);
            // Only run this check if the currently viewed date is today
            if (currentSelectedDate !== todayDateStr) {
                return;
            }
            const currentTimeStr = getCurrentTimeString(BOSTON_TIMEZONE);

            // Get column elements
            const todoCol = document.getElementById('todo');
            const inProgressCol = document.getElementById('inprogress');
            if (!todoCol || !inProgressCol) { console.error("Cannot find columns for auto-move."); return; }
            const todoTasksContainer = todoCol.querySelector('.tasks-container');
            const inProgressTasksContainer = inProgressCol.querySelector('.tasks-container');
            if (!todoTasksContainer || !inProgressTasksContainer) { console.error("Cannot find task containers for auto-move."); return; }

            const tasksInTodo = todoTasksContainer.querySelectorAll('.kanban-task');
            let taskMoved = false; // Flag to check if any task was moved

            tasksInTodo.forEach(task => {
                if (task.classList.contains('editing')) { return; } // Skip tasks being edited
                const taskStartTime = task.dataset.startTime; // This will be undefined if no time was set
                // If task has a start time and the current time is past it
                if (taskStartTime && currentTimeStr >= taskStartTime) {
                    console.log(`Auto-moving task "${task.dataset.text}" (ID: ${task.id}) to In Progress`);
                    // Add progress elements if not already present and times exist
                    if (task.dataset.startTime && task.dataset.endTime && !task.querySelector('.task-progress-container')) {
                        task.appendChild(createProgressElements());
                    }
                    // Move the task element to the 'In Progress' container
                    inProgressTasksContainer.appendChild(task);
                    taskMoved = true;
                    // Add a temporary highlight class
                    task.classList.add('task-just-moved');
                    setTimeout(() => {
                        task.classList.remove('task-just-moved');
                    }, 1800); // Remove highlight after 1.8 seconds
                }
            });

            // If any task was moved, save the board state and update timers
            if (taskMoved) {
                await saveCurrentBoardState();
                updateInProgressTimers();
            }
        }

        // Displays a random motivational quote
        function displayMotivationalQuote() {
            if (!quoteDisplay || motivationalQuotes.length === 0) return;
            let randomIndex;
            // Ensure the new quote is different from the last one shown, if possible
            if (motivationalQuotes.length > 1) {
                do {
                    randomIndex = Math.floor(Math.random() * motivationalQuotes.length);
                } while (randomIndex === currentQuoteIndex);
            } else {
                randomIndex = 0; // Only one quote available
            }
            currentQuoteIndex = randomIndex; // Update the index
            quoteDisplay.textContent = motivationalQuotes[currentQuoteIndex]; // Set the text content
        }

        // --- In Progress Timer Update Functions ---

        // Updates the progress bar and remaining time for a single task
        function updateSingleTaskTimer(taskElement) {
            const progressBarFill = taskElement.querySelector('.progress-bar-fill');
            const remainingTimeSpan = taskElement.querySelector('.remaining-time');
            const startTimeStr = taskElement.dataset.startTime;
            const endTimeStr = taskElement.dataset.endTime;

            // Ensure necessary elements and data are present
            if (!progressBarFill || !remainingTimeSpan || !startTimeStr || !endTimeStr) {
                return Infinity; // Return a large number if data is missing
            }

            try {
                const now = new Date();
                // Create Date objects using the currently selected date and the task times
                const startDate = new Date(`${currentSelectedDate}T${startTimeStr}:00`);
                const endDate = new Date(`${currentSelectedDate}T${endTimeStr}:00`);

                // Validate dates
                if (isNaN(startDate) || isNaN(endDate) || endDate <= startDate) {
                    remainingTimeSpan.textContent = 'Invalid Time';
                    progressBarFill.style.width = '0%';
                    return Infinity;
                }

                // Calculate durations and percentage
                const totalDurationMillis = endDate - startDate;
                const elapsedMillis = now - startDate;
                const remainingMillis = endDate - now;
                let percentage = (elapsedMillis / totalDurationMillis) * 100;
                percentage = Math.max(0, Math.min(100, percentage)); // Clamp between 0 and 100

                // Update progress bar width
                progressBarFill.style.width = `${percentage}%`;

                // Update remaining time text
                const remainingSecondsTotal = Math.round(remainingMillis / 1000);
                remainingTimeSpan.classList.toggle('expired', remainingSecondsTotal < 0); // Add 'expired' class if time is up

                if (remainingSecondsTotal < 0) {
                    remainingTimeSpan.textContent = 'Time Up!';
                } else if (remainingSecondsTotal < 60) {
                    // Display seconds if less than a minute remains
                    remainingTimeSpan.textContent = `${remainingSecondsTotal}s left`;
                } else {
                    // Display minutes otherwise
                    const remainingMinutes = Math.ceil(remainingSecondsTotal / 60);
                    remainingTimeSpan.textContent = `${remainingMinutes}m left`;
                }
                return remainingSecondsTotal; // Return remaining seconds for interval adjustment

            } catch (e) {
                console.error("Error updating timer for task:", taskElement.id, e);
                remainingTimeSpan.textContent = 'Error';
                progressBarFill.style.width = '0%';
                return Infinity; // Return large number on error
            }
        }

        // Updates timers for all tasks currently in the 'In Progress' column
        function updateInProgressTimers() {
            const inProgressColumn = document.getElementById('inprogress');
            const tasksContainer = inProgressColumn?.querySelector('.tasks-container');
            if (!tasksContainer) return; // Exit if container not found

            const tasks = tasksContainer.querySelectorAll('.kanban-task');
            let isInLastMinute = false; // Flag if any task has < 60s remaining

            tasks.forEach(task => {
                 // Ensure progress elements exist if task should have them (has times)
                 if (task.dataset.startTime && task.dataset.endTime && !task.querySelector('.task-progress-container')) {
                     task.appendChild(createProgressElements());
                 }
                 // Update the timer for this task
                 const remainingSeconds = updateSingleTaskTimer(task);
                 // Check if this task triggers the need for faster updates
                 if (remainingSeconds >= 0 && remainingSeconds < 60) {
                     isInLastMinute = true;
                 }
            });

            // Adjust update interval based on whether any task is in its last minute
            if (isInLastMinute && !lastMinuteIntervalId) {
                // Switch to faster (1-second) updates
                clearInterval(progressTimerIntervalId); // Clear the slower interval
                progressTimerIntervalId = null;
                lastMinuteIntervalId = setInterval(updateInProgressTimers, LAST_MINUTE_INTERVAL);
                console.log("Starting last minute timer interval (1s).");
            } else if (!isInLastMinute && lastMinuteIntervalId) {
                // Switch back to slower updates if no tasks are in the last minute
                clearInterval(lastMinuteIntervalId); // Clear the faster interval
                lastMinuteIntervalId = null;
                // Restart the regular interval only if it's not already running
                if (!progressTimerIntervalId) {
                    progressTimerIntervalId = setInterval(updateInProgressTimers, TIMER_UPDATE_INTERVAL);
                    console.log("Stopping last minute timer, restarting regular interval (15s).");
                }
            }
        }

        // --- Initialization ---
        // Runs when the DOM content is fully loaded
        document.addEventListener('DOMContentLoaded', async () => {
            console.log("DOM fully loaded and parsed.");

            // Initial setup for time display and quote
            updateTimeDisplay();
            setInterval(updateTimeDisplay, 60000); // Update time every minute
            displayMotivationalQuote();

            // --- Crucial Check: Ensure Firebase initialized ---
            if (!db) {
                console.error("DB not initialized. Aborting further setup.");
                // Display error message prominently if DB connection failed earlier
                if(selectedDateDisplay) selectedDateDisplay.textContent = "Database Connection Failed! Check Config.";
                // Disable interaction if DB failed
                document.querySelectorAll('button, input').forEach(el => el.disabled = true);
                return; // Stop initialization
            }
            // --- End DB Check ---

            console.log("Database connection available. Proceeding...");

            // Run the archiving process for past dates on load
            try {
                 await runArchivingProcess();
            } catch (error) {
                 console.error("Error during initial archiving:", error);
            }

            // Load Idea Box tasks first
             try {
                 await displayIdeaTasks();
             } catch(error) {
                 // Error is logged within loadIdeaTasksFromFirestore now
                 console.error("Failed initial idea task load (caught in DOMContentLoaded):", error);
             }


            // Load tasks for the current date
            const currentBostonDate = getCurrentDateString(BOSTON_TIMEZONE);
            if (dateSelector) {
                dateSelector.value = currentBostonDate; // Set date picker to today
                try {
                    await displayTasksForDate(currentBostonDate); // Load today's tasks
                } catch (error) {
                    // Error is logged within loadTasksFromFirestore and handled in displayTasksForDate
                    console.error("Failed initial daily task load (caught in DOMContentLoaded):", error);
                }
                 // Add event listener for date changes *after* initial load attempt
                dateSelector.addEventListener('change', (event) => {
                    displayTasksForDate(event.target.value); // Load tasks for the newly selected date
                });
            } else {
                // Fallback if date selector element isn't found (shouldn't happen)
                console.error("Date selector element not found.");
                try { await displayTasksForDate(currentBostonDate); } catch (error) { /* Handled in displayTasksForDate */ }
            }

            // Load and display the summary for yesterday
            try {
                 await displayLatestSummary();
            } catch(error) {
                 console.error("Failed to display latest summary:", error);
            }

            // --- Add Event Listeners for Forms and Modals ---
            const addTaskBtnLocal = document.getElementById('add-task-btn');
            if (addTaskBtnLocal) {
                addTaskBtnLocal.addEventListener('click', addTask);
                // Allow adding daily tasks by pressing Enter in form fields
                const dailyTaskInputs = ['new-task-input', 'new-task-start-time', 'new-task-end-time'];
                dailyTaskInputs.forEach(id => {
                    const input = document.getElementById(id);
                    if (input) input.addEventListener('keypress', (event) => { if (event.key === 'Enter') addTask(); });
                });
            } else { console.error("Add daily task button not found."); }

            if (addIdeaTaskBtn && ideaTaskInput) {
                addIdeaTaskBtn.addEventListener('click', addIdeaTask);
                // Allow adding idea tasks by pressing Enter in the input field
                ideaTaskInput.addEventListener('keypress', (event) => { if (event.key === 'Enter') addIdeaTask(); });
            } else { console.error("Add idea task button or input not found."); }

            // Add listeners for modal buttons
            if (modalSaveBtn) modalSaveBtn.addEventListener('click', handleModalSave);
            if (modalCancelBtn) modalCancelBtn.addEventListener('click', hideTimePrompt);

            // --- Start Background Intervals ---
            // Start interval to check for tasks whose start time has passed
            if (taskCheckIntervalId) clearInterval(taskCheckIntervalId); // Clear existing if any
            taskCheckIntervalId = setInterval(checkAndMoveTasks, TASK_CHECK_INTERVAL);
            console.log(`Started task check interval (${TASK_CHECK_INTERVAL / 1000}s). ID: ${taskCheckIntervalId}`);

            // Start interval to update progress timers for 'In Progress' tasks
            if (progressTimerIntervalId) clearInterval(progressTimerIntervalId); // Clear existing if any
            if (lastMinuteIntervalId) clearInterval(lastMinuteIntervalId); // Clear existing if any
            progressTimerIntervalId = setInterval(updateInProgressTimers, TIMER_UPDATE_INTERVAL);
            console.log(`Started progress timer interval (${TIMER_UPDATE_INTERVAL / 1000}s). ID: ${progressTimerIntervalId}`);

            console.log("Initialization complete.");
        });
    </script>

</body>
</html>
